Question ID,Unformatted Answer
1,"[{'role': 'assistant', 'type': 'message', 'content': ""The task requires checking the entire dataset to determine the number of passengers who survived. Let's calculate that now.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Count the number of passengers who survived in the entire dataset\nnumber_survived = data['Survived'].sum()\nnumber_survived""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.int64(342)'}, {'role': 'assistant', 'type': 'message', 'content': 'A total of 342 passengers survived in the Titanic dataset. Let me know if there is anything else you would like to explore or analyze!'}]"
2,"[{'role': 'assistant', 'type': 'message', 'content': ""Let's calculate the number of male and female passengers in the entire dataset.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Count the number of male and female passengers in the dataset\ngender_counts = data['Sex'].value_counts()\ngender_counts""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'Sex\nmale      577\nfemale    314\nName: count, dtype: int64'}, {'role': 'assistant', 'type': 'message', 'content': 'The dataset contains 577 male passengers and 314 female passengers. If you have any more questions or need further analysis, feel free to ask!'}]"
3,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the mean, median, and standard deviation of the ""Age"" variable, we\'ll first drop any rows with missing values in the ""Age"" column according to the specified rules, and then calculate these statistics. Let\'s proceed with that.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Drop missing values in 'Age' before performing analysis\nage_data = data['Age'].dropna()\n\n# Calculate mean, median, and standard deviation of 'Age'\nage_mean = age_data.mean()\nage_median = age_data.median()\nage_std = age_data.std()\n\nage_statistics = {\n    'mean': age_mean,\n    'median': age_median,\n    'standard_deviation': age_std\n}\nage_statistics""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""{'mean': np.float64(29.69911764705882),\n 'median': np.float64(28.0),\n 'standard_deviation': np.float64(14.526497332334042)}""}, {'role': 'assistant', 'type': 'message', 'content': 'The age statistics are as follows:\n\n- Mean: 29.699\n- Median: 28.000\n- Standard Deviation: 14.526\n\nFeel free to ask if you need more analyses or any further information!'}]"
4,"[{'role': 'assistant', 'type': 'message', 'content': 'Let\'s determine the number of unique values in the ""Pclass"" column, which denotes the passenger class.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Count the number of unique values in 'Pclass'\nunique_pclass_values = data['Pclass'].nunique()\nunique_pclass_values""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '3'}, {'role': 'assistant', 'type': 'message', 'content': 'There are 3 different values in the ""Pclass"" column, representing different passenger classes. If you have any other questions or need further analysis, let me know!'}]"
5,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the average ""Fare"" price, we\'ll calculate the mean of that column. Let\'s proceed.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the mean of 'Fare'\naverage_fare = data['Fare'].mean()\naverage_fare""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(32.204207968574636)'}, {'role': 'assistant', 'type': 'message', 'content': 'The average fare price is approximately 32.204. If you need further analysis or insights, feel free to ask!'}]"
6,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the correlation between ""Pclass"" and ""Fare,"" we will compute the correlation coefficient between these two variables. Let\'s do this analysis.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the correlation coefficient between 'Pclass' and 'Fare'\ncorrelation_pclass_fare = data['Pclass'].corr(data['Fare'])\ncorrelation_pclass_fare""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(-0.5494996199439078)'}, {'role': 'assistant', 'type': 'message', 'content': 'The correlation coefficient between ""Pclass"" and ""Fare"" is approximately -0.549. This indicates a moderate negative correlation, meaning that as the passenger class increases (from 1st to 3rd), the fare tends to decrease. If you have more questions or need additional analysis, feel free to ask!'}]"
7,"[{'role': 'assistant', 'type': 'message', 'content': ""To determine if there is a statistically significant difference in fare price between passengers who survived and those who did not, we'll perform an independent t-test. This test will compare the means of the two groups.\n\nLet's proceed with the analysis.""}]"
8,"[{'role': 'assistant', 'type': 'message', 'content': ""To determine if there is a statistically significant difference in fare prices between men and women, we can perform an independent t-test. This will compare the average fares of male and female passengers. Let's conduct this analysis.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import ttest_ind\n\n# Fare data for male and female passengers\nfare_male = data[data['Sex'] == 'male']['Fare']\nfare_female = data[data['Sex'] == 'female']['Fare']\n\n# Perform t-test\nstatistic, p_value = ttest_ind(fare_male, fare_female, nan_policy='omit')\np_value, statistic""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(4.230867870042998e-08), np.float64(-5.529140269385719))'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value from the t-test comparing fare prices between men and women is approximately \\(4.231 \\times 10^{-8}\\). Since this p-value is significantly less than the significance level of 0.05, we conclude that there is a statistically significant difference in fare prices between male and female passengers.\n\nIf you have further questions or need more analysis, please let me know!'}]"
9,"[{'role': 'assistant', 'type': 'message', 'content': 'To analyze the difference in fare prices between young and old passengers, I will:\n\n1. Create a new categorical variable ""Age_categorical"" in the dataset, where passengers aged 50 years or older are labeled as ""old"", and those younger than 50 are labeled as ""young"".\n2. Use a statistical test to compare the fare prices between the two age groups.\n\nLet\'s implement this and perform the analysis.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create the 'Age_categorical' variable\ndata['Age_categorical'] = data['Age'].apply(lambda x: 'old' if x >= 50 else 'young')\n\n# Fare data for young and old passengers\nfare_young = data[data['Age_categorical'] == 'young']['Fare']\nfare_old = data[data['Age_categorical'] == 'old']['Fare']\n\n# Perform t-test\nstatistic_age, p_value_age = ttest_ind(fare_young, fare_old, nan_policy='omit')\n\np_value_age, statistic_age""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.01039460814600385), np.float64(-2.567881084492845))'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value from the t-test comparing fare prices between young and old passengers is approximately 0.010. Since this p-value is less than the significance level of 0.05, we conclude that there is a statistically significant difference in fare prices between young and old passengers.\n\nIf you have more questions or need further analysis, feel free to ask!'}]"
10,"[{'role': 'assistant', 'type': 'message', 'content': 'To predict survival using logistic regression with the features ""Pclass"", ""Age_categorical"", and ""Fare"", we will follow these steps:\n\n1. Encode the categorical variable ""Age_categorical"".\n2. Prepare feature matrices for the training and test sets.\n3. Fit a logistic regression model on the training data.\n4. Predict probabilities on the test set.\n5. Calculate the Area Under the Receiver Operating Characteristic curve (AUROC) score.\n\nLet\'s proceed with these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.preprocessing import OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\n\n# Prepare data by encoding 'Age_categorical'\nfeatures = ['Pclass', 'Age_categorical', 'Fare']\nX_train = train_data[features]\nX_test = test_data[features]\ny_train = train_data['Survived']\ny_test = test_data['Survived']\n\n# Create a column transformer for one-hot encoding\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('cat', OneHotEncoder(), ['Age_categorical'])\n    ], remainder='passthrough')\n\n# Create a pipeline with logistic regression\nmodel = Pipeline(steps=[('preprocessor', preprocessor),\n                        ('classifier', LogisticRegression(max_iter=200))])\n\n# Fit the model\nmodel.fit(X_train, y_train)\n\n# Predict and calculate AUROC\ny_probs = model.predict_proba(X_test)[:, 1]\nauroc = roc_auc_score(y_test, y_probs)\nauroc""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[367], line 18\n     16 features = [\'Pclass\', \'Age_categorical\', \'Fare\']\n     17 print(\'##active_line9##\')\n---> 18 X_train = train_data[features]\n     19 print(\'##active_line10##\')\n     20 X_test = test_data[features]\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/frame.py:4108, in DataFrame.__getitem__(self, key)\n   4106     if is_iterator(key):\n   4107         key = list(key)\n-> 4108     indexer = self.columns._get_indexer_strict(key, ""columns"")[1]\n   4110 # take() does not accept boolean indexers\n   4111 if getattr(indexer, ""dtype"", None) == bool:\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:6200, in Index._get_indexer_strict(self, key, axis_name)\n   6197 else:\n   6198     keyarr, indexer, new_indexer = self._reindex_non_unique(keyarr)\n-> 6200 self._raise_if_missing(keyarr, indexer, axis_name)\n   6202 keyarr = self.take(indexer)\n   6203 if isinstance(key, Index):\n   6204     # GH 42790 - Preserve name from an Index\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:6252, in Index._raise_if_missing(self, key, indexer, axis_name)\n   6249     raise KeyError(f""None of [{key}] are in the [{axis_name}]"")\n   6251 not_found = list(ensure_index(key)[missing_mask.nonzero()[0]].unique())\n-> 6252 raise KeyError(f""{not_found} not in index"")\n\nKeyError: ""[\'Age_categorical\'] not in index""'}, {'role': 'assistant', 'type': 'message', 'content': 'It seems that the ""Age_categorical"" column was created in the entire dataset but wasn\'t available in the split datasets (`train_data` and `test_data`). Let me fix this issue by ensuring that the ""Age_categorical"" column is added to both the training and test datasets. Then we can proceed with the logistic regression and AUROC score calculation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Add 'Age_categorical' column to train and test data\ntrain_data['Age_categorical'] = train_data['Age'].apply(lambda x: 'old' if x >= 50 else 'young')\ntest_data['Age_categorical'] = test_data['Age'].apply(lambda x: 'old' if x >= 50 else 'young')\n\n# Prepare the features again\nX_train = train_data[features]\nX_test = test_data[features]\ny_train = train_data['Survived']\ny_test = test_data['Survived']\n\n# Redefine the preprocessor and model pipeline, and fit the model\nmodel.fit(X_train, y_train)\n\n# Predict and calculate AUROC\ny_probs = model.predict_proba(X_test)[:, 1]\nauroc = roc_auc_score(y_test, y_probs)\nauroc""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'Output truncated. Showing the last 2800 characters. You should try again and use computer.ai.summarize(output) over the output, or break it down into smaller steps.\n\n\n   2958                 check_y_params = {**default_check_params, **check_y_params}\n   2959             y = check_array(y, input_name=""y"", **check_y_params)\n   2960         else:\n-> 2961             X, y = check_X_y(X, y, **check_params)\n   2962         out = X, y\n   2963 \n   2964     if not no_val_X and check_params.get(""ensure_2d"", True):\n\n~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(X, y, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_all_finite, ensure_2d, allow_nd, multi_output, ensure_min_samples, ensure_min_features, y_numeric, estimator)\n   1366         )\n   1367 \n   1368     ensure_all_finite = _deprecate_force_all_finite(force_all_finite, ensure_all_finite)\n   1369 \n-> 1370     X = check_array(\n   1371         X,\n   1372         accept_sparse=accept_sparse,\n   1373         accept_large_sparse=accept_large_sparse,\n\n~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/sklearn/utils/validation.py in ?(array, accept_sparse, accept_large_sparse, dtype, order, copy, force_writeable, force_all_finite, ensure_all_finite, ensure_non_negative, ensure_2d, allow_nd, ensure_min_samples, ensure_min_features, estimator, input_name)\n   1052                         )\n   1053                     array = xp.astype(array, dtype, copy=False)\n   1054                 else:\n   1055                     array = _asarray_with_order(array, order=order, dtype=dtype, xp=xp)\n-> 1056             except ComplexWarning as complex_warning:\n   1057                 raise ValueError(\n   1058                     ""Complex data not supported\\n{}\\n"".format(array)\n   1059                 ) from complex_warning\n\n~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/sklearn/utils/_array_api.py in ?(array, dtype, order, copy, xp, device)\n    835         # Use NumPy API to support order\n    836         if copy is True:\n    837             array = numpy.array(array, order=order, dtype=dtype)\n    838         else:\n--> 839             array = numpy.asarray(array, order=order, dtype=dtype)\n    840 \n    841         # At this point array is a NumPy ndarray. We convert it to an array\n    842         # container that is consistent with the input\'s namespace.\n\n~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/generic.py in ?(self, dtype, copy)\n   2149     def __array__(\n   2150         self, dtype: npt.DTypeLike | None = None, copy: bool_t | None = None\n   2151     ) -> np.ndarray:\n   2152         values = self._values\n-> 2153         arr = np.asarray(values, dtype=dtype)\n   2154         if (\n   2155             astype_is_view(values.dtype, arr.dtype)\n   2156             and using_copy_on_write()\n\nValueError: could not convert string to float: \'young\''}, {'role': 'assistant', 'type': 'message', 'content': 'The error occurred due to attempting to use logistic regression with a categorical variable that wasn\'t properly encoded into numerical values. Let\'s address this by ensuring the ""Age_categorical"" variable is converted to numerical values using one-hot encoding before fitting the model. I\'ll fix this and re-run the logistic regression analysis.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Ensure 'Age_categorical' is encoded properly\n# Redefine the preprocessor and model pipeline with correct encoding\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('cat', OneHotEncoder(drop='first'), ['Age_categorical'])  # Use drop='first' to avoid dummy variable trap\n    ], remainder='passthrough')\n\n# Re-create the pipeline\nmodel = Pipeline(steps=[('preprocessor', preprocessor),\n                        ('classifier', LogisticRegression(max_iter=200))])\n\n# Fit the model\nmodel.fit(X_train, y_train)\n\n# Predict and calculate AUROC\ny_probs = model.predict_proba(X_test)[:, 1]\nauroc = roc_auc_score(y_test, y_probs)\nauroc""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.761068211068211)'}, {'role': 'assistant', 'type': 'message', 'content': 'The AUROC score for predicting survival using logistic regression with ""Pclass"", ""Age_categorical"", and ""Fare"" as features is approximately 0.761. This indicates a good model performance based on the test data.\n\nIf you need further analysis or have additional questions, feel free to let me know!'}]"
11,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average and standard deviation for 'SalePrice'\nmean_sale_price = df['SalePrice'].mean()\nstd_sale_price = df['SalePrice'].std()\n\nmean_sale_price, std_sale_price""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(180921.19589041095), np.float64(79442.50288288662))'}, {'role': 'assistant', 'type': 'message', 'content': 'The average ""SalePrice"" is approximately $180,921.196, and the standard deviation is approximately $79,442.503. Let me know if there\'s anything else you\'d like to analyze!'}]"
12,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create the new variable 'TotalSF' as the sum of '1stFlrSF' and '2ndFlrSF'\ndf['TotalSF'] = df['1stFlrSF'] + df['2ndFlrSF']\n\n# Calculate the mean of the new variable 'TotalSF'\nmean_total_sf = df['TotalSF'].mean()\n\nmean_total_sf""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(1509.6191780821919)'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean value of the new variable ""TotalSF"" is approximately 1,509.619 square feet. If you need further analysis or transformations, feel free to ask!'}]"
13,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Temporarily drop rows with missing 'GarageYrBlt' for exploratory analysis\nmean_before_imputation = df['GarageYrBlt'].mean()\n\n# Impute missing values in 'GarageYrBlt' with the median of the train dataset\nmedian_garage_yr_blt = train_df['GarageYrBlt'].median()\ntrain_df['GarageYrBlt'].fillna(median_garage_yr_blt, inplace=True)\ntest_df['GarageYrBlt'].fillna(median_garage_yr_blt, inplace=True)\n\n# Update the entire dataframe\ndf['GarageYrBlt'].fillna(median_garage_yr_blt, inplace=True)\n\n# Recalculate the mean\nmean_after_imputation = df['GarageYrBlt'].mean()\n\nmean_before_imputation, mean_after_imputation""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""/var/folders/fz/1btg0vkx2yl8sf_1hwcxk5dw0000gn/T/ipykernel_18994/891728156.py:12: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\nThe behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n\nFor example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n\n\n  train_df['GarageYrBlt'].fillna(median_garage_yr_blt, inplace=True)\n/var/folders/fz/1btg0vkx2yl8sf_1hwcxk5dw0000gn/T/ipykernel_18994/891728156.py:14: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\nThe behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n\nFor example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n\n\n  test_df['GarageYrBlt'].fillna(median_garage_yr_blt, inplace=True)\n/var/folders/fz/1btg0vkx2yl8sf_1hwcxk5dw0000gn/T/ipykernel_18994/891728156.py:20: FutureWarning: A value is trying to be set on a copy of a DataFrame or Series through chained assignment using an inplace method.\nThe behavior will change in pandas 3.0. This inplace method will never work because the intermediate object on which we are setting values always behaves as a copy.\n\nFor example, when doing 'df[col].method(value, inplace=True)', try using 'df.method({col: value}, inplace=True)' or df[col] = df[col].method(value) instead, to perform the operation inplace on the original object.\n\n\n  df['GarageYrBlt'].fillna(median_garage_yr_blt, inplace=True)\n(np.float64(1978.5061638868744), np.float64(1978.5890410958905))""}, {'role': 'assistant', 'type': 'message', 'content': 'Before imputation, the mean value of ""GarageYrBlt"" was approximately 1978.506. After imputing the missing values with the median, the new mean is approximately 1978.589. Let me know if there\'s anything else you would like to perform on the dataset!'}]"
14,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': '# Calculate the number of missing values for each column\nmissing_values = df.isnull().sum()\n\n# Find the column with the maximum missing values\nmax_missing_variable = missing_values.idxmax()\nmax_missing_values = missing_values.max()\n\nmax_missing_variable, max_missing_values'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""('PoolQC', np.int64(1453))""}, {'role': 'assistant', 'type': 'message', 'content': 'The variable ""PoolQC"" has the highest missingness with a total of 1,453 missing values. If you need further insights or operations on the dataset, feel free to ask!'}]"
15,"[{'role': 'assistant', 'type': 'message', 'content': 'To perform a linear regression of ""SalePrice"" on ""TotalSF"", we will use the training dataset to fit the model and then evaluate the statistical significance of the coefficient. Let\'s proceed with these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\nimport statsmodels.api as sm\n\n# Define the features and target variable for the regression model\nX_train = train_df[['TotalSF']]\ny_train = train_df['SalePrice']\n\n# Fit the linear regression model\nlinear_model = LinearRegression().fit(X_train, y_train)\n\n# Get the coefficient and intercept from sklearn\ncoefficient = linear_model.coef_[0]\nintercept = linear_model.intercept_\n\n# Use statsmodels to check the statistical significance of the coefficient\nX_train_sm = sm.add_constant(X_train) # Adding a constant for the intercept\nmodel = sm.OLS(y_train, X_train_sm).fit()\n\n# Get the p-value for the coefficient\np_value = model.pvalues['TotalSF']\n\ncoefficient, intercept, p_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[375], line 10\n      8 pass\n      9 print(\'##active_line5##\')\n---> 10 X_train = train_df[[\'TotalSF\']]\n     11 print(\'##active_line6##\')\n     12 y_train = train_df[\'SalePrice\']\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/frame.py:4108, in DataFrame.__getitem__(self, key)\n   4106     if is_iterator(key):\n   4107         key = list(key)\n-> 4108     indexer = self.columns._get_indexer_strict(key, ""columns"")[1]\n   4110 # take() does not accept boolean indexers\n   4111 if getattr(indexer, ""dtype"", None) == bool:\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:6200, in Index._get_indexer_strict(self, key, axis_name)\n   6197 else:\n   6198     keyarr, indexer, new_indexer = self._reindex_non_unique(keyarr)\n-> 6200 self._raise_if_missing(keyarr, indexer, axis_name)\n   6202 keyarr = self.take(indexer)\n   6203 if isinstance(key, Index):\n   6204     # GH 42790 - Preserve name from an Index\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:6249, in Index._raise_if_missing(self, key, indexer, axis_name)\n   6247 if nmissing:\n   6248     if nmissing == len(indexer):\n-> 6249         raise KeyError(f""None of [{key}] are in the [{axis_name}]"")\n   6251     not_found = list(ensure_index(key)[missing_mask.nonzero()[0]].unique())\n   6252     raise KeyError(f""{not_found} not in index"")\n\nKeyError: ""None of [Index([\'TotalSF\'], dtype=\'object\')] are in the [columns]""'}, {'role': 'assistant', 'type': 'message', 'content': 'It seems like there was an issue accessing the ""TotalSF"" column in the training dataset. Let me ensure the ""TotalSF"" variable is added to both the training and testing datasets before proceeding with the regression analysis.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Ensure 'TotalSF' is added to train and test data\ntrain_df['TotalSF'] = train_df['1stFlrSF'] + train_df['2ndFlrSF']\ntest_df['TotalSF'] = test_df['1stFlrSF'] + test_df['2ndFlrSF']\n\n# Re-run the regression with the updated train data\nX_train = train_df[['TotalSF']]\ny_train = train_df['SalePrice']\n\n# Fit the linear regression model\nlinear_model = LinearRegression().fit(X_train, y_train)\n\n# Get the coefficient and intercept\ncoefficient = linear_model.coef_[0]\nintercept = linear_model.intercept_\n\n# Use statsmodels to check the statistical significance of the coefficient\nX_train_sm = sm.add_constant(X_train) # Adding a constant for the intercept\nmodel = sm.OLS(y_train, X_train_sm).fit()\n\n# Get the p-value for the coefficient\np_value = model.pvalues['TotalSF']\n\ncoefficient, intercept, p_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(104.45920904705942),\n np.float64(22485.391165916837),\n np.float64(1.1520728062735227e-174))'}, {'role': 'assistant', 'type': 'message', 'content': 'The coefficient for ""TotalSF"" in the linear regression model is approximately 104.459. The intercept value is approximately 22,485.391. The p-value for the coefficient is extremely small, approximately \\(1.152 \\times 10^{-174}\\), indicating that the coefficient is statistically significant at the 0.05 significance level. If you have further questions or need additional analyses, feel free to ask!'}]"
16,"[{'role': 'assistant', 'type': 'message', 'content': 'To perform this regression, we\'ll need to encode the categorical variable ""LotShape"" into a suitable format (e.g., one-hot encoding) before fitting the linear regression model. Let\'s proceed with these steps and evaluate the model\'s performance.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import OneHotEncoder\nimport numpy as np\n\n# One-hot encode the 'LotShape' feature\nencoder = OneHotEncoder(drop='first', sparse=False)\nencoded_train_lotshape = encoder.fit_transform(train_df[['LotShape']])\nencoded_test_lotshape = encoder.transform(test_df[['LotShape']])\n\n# Combine the features into training and testing sets\nX_train_combined = np.hstack((train_df[['TotalSF', 'GarageArea']], encoded_train_lotshape))\nX_test_combined = np.hstack((test_df[['TotalSF', 'GarageArea']], encoded_test_lotshape))\ny_train = train_df['SalePrice']\ny_test = test_df['SalePrice']\n\n# Fit the linear regression model\nlinear_model_combined = LinearRegression().fit(X_train_combined, y_train)\n\n# Calculate the R-squared value for the train set\ntrain_r_squared = linear_model_combined.score(X_train_combined, y_train)\n\n# Make predictions on the test set and calculate RMSE\npredictions = linear_model_combined.predict(X_test_combined)\ntest_rmse = np.sqrt(mean_squared_error(y_test, predictions))\n\ntrain_r_squared, test_rmse""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[377], line 12\n     10 pass\n     11 print('##active_line6##')\n---> 12 encoder = OneHotEncoder(drop='first', sparse=False)\n     13 print('##active_line7##')\n     14 encoded_train_lotshape = encoder.fit_transform(train_df[['LotShape']])\n\nTypeError: OneHotEncoder.__init__() got an unexpected keyword argument 'sparse'""}, {'role': 'assistant', 'type': 'message', 'content': ""It seems there was an issue with the `OneHotEncoder` initialization due to an argument name change. I will correct this and rerun the analysis. The correct argument name is `sparse_output`. Let's update the code and proceed.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.preprocessing import OneHotEncoder\n\n# Correct one-hot encoding with the updated argument\nencoder = OneHotEncoder(drop='first', sparse_output=False)\nencoded_train_lotshape = encoder.fit_transform(train_df[['LotShape']])\nencoded_test_lotshape = encoder.transform(test_df[['LotShape']])\n\n# Combine the features into training and testing sets\nX_train_combined = np.hstack((train_df[['TotalSF', 'GarageArea']], encoded_train_lotshape))\nX_test_combined = np.hstack((test_df[['TotalSF', 'GarageArea']], encoded_test_lotshape))\ny_train = train_df['SalePrice']\ny_test = test_df['SalePrice']\n\n# Fit the linear regression model\nlinear_model_combined = LinearRegression().fit(X_train_combined, y_train)\n\n# Calculate the R-squared value for the train set\ntrain_r_squared = linear_model_combined.score(X_train_combined, y_train)\n\n# Make predictions on the test set and calculate RMSE\npredictions = linear_model_combined.predict(X_test_combined)\ntest_rmse = np.sqrt(mean_squared_error(y_test, predictions))\n\ntrain_r_squared, test_rmse""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(0.6116385046485842, np.float64(49768.43986369762))'}, {'role': 'assistant', 'type': 'message', 'content': 'The R-squared value for the training dataset is approximately 0.612, indicating that about 61.2% of the variance in ""SalePrice"" can be explained by the model. The test RMSE (Root Mean Squared Error) is approximately $49,768.440. Let me know if there\'s anything else you\'d like to explore or analyze!'}]"
17,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if there is a statistically significant difference in ""SalePrice"" between the different values of ""LotShape"", we can perform an ANOVA (Analysis of Variance) test. This test will help identify if any of the means of ""SalePrice"" across ""LotShape"" categories are significantly different from each other. Let\'s proceed with the ANOVA test.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import f_oneway\n\n# Drop rows with missing SalePrice or LotShape\nanova_df = df.dropna(subset=['SalePrice', 'LotShape'])\n\n# Perform ANOVA test\nanova_results = f_oneway(\n    *(anova_df[anova_df['LotShape'] == category]['SalePrice'] for category in anova_df['LotShape'].unique())\n)\n\nanova_results.statistic, anova_results.pvalue""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(40.13285166226295), np.float64(6.447523852014698e-25))'}, {'role': 'assistant', 'type': 'message', 'content': 'The ANOVA test statistic is approximately 40.133, and the p-value is approximately \\(6.448 \\times 10^{-25}\\). This highly significant p-value indicates that there is a statistically significant difference in ""SalePrice"" between the different values of ""LotShape"". If you have any more questions or need further analysis, feel free to ask!'}]"
18,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import pearsonr\n\n# Drop rows with missing values in 'SalePrice' or 'TotalSF'\ncorrelation_df = df.dropna(subset=['SalePrice', 'TotalSF'])\n\n# Calculate the Pearson correlation coefficient and p-value\ncorrelation, p_value = pearsonr(correlation_df['SalePrice'], correlation_df['TotalSF'])\n\ncorrelation, p_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.7168830793692811), np.float64(1.183940787187048e-230))'}, {'role': 'assistant', 'type': 'message', 'content': 'The correlation between ""SalePrice"" and ""TotalSF"" is approximately 0.717. The p-value for this correlation is extremely small, approximately \\(1.184 \\times 10^{-230}\\), indicating a statistically significant positive correlation. If you have more inquiries or need further assistance, let me know!'}]"
19,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if the distribution of ""SalePrice"" is normal, we can perform a normality test such as the Shapiro-Wilk test or visualize the distribution using a histogram and a Q-Q plot. Let\'s start by conducting these analyses.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': 'import matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import shapiro, probplot\n\n# Shapiro-Wilk test for normality\nshapiro_stat, shapiro_p_value = shapiro(df[\'SalePrice\'].dropna())\n\n# Plotting histogram and Q-Q plot\nplt.figure(figsize=(14, 6))\n\nplt.subplot(1, 2, 1)\nsns.histplot(df[\'SalePrice\'].dropna(), kde=True)\nplt.title(\'Histogram of SalePrice\')\n\nplt.subplot(1, 2, 2)\nprobplot(df[\'SalePrice\'].dropna(), dist=""norm"", plot=plt)\nplt.title(\'Q-Q Plot of SalePrice\')\n\nplt.tight_layout()\nplt.show()\n\nshapiro_stat, shapiro_p_value'}, {'role': 'computer', 'type': 'image', 'format': 'base64.png', 'content': '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Xlg2CWzWrJnzXuX5S7wv2Ndml8lZX1jvpVw//vijM8m1SZt9HyoT2h511FHO98NaPFiFhJ3bFjawya6d1xYoM6eddppThXD22Wc7AbF93dbCwn5+pQWdRT300EPOYgy9evVyFg+z19gHDLv0zCoU7HFVsZ+bhfhWtX344Yc7i2VYb9rffvvN+frt+2cTX2vLYSG/9WKzim/7+a5bt84Zt53DJsUAAADlYQUIr776qrNmgF2Wb4vQWq9Sm6+++OKLTkWtrZFQnv6lVXG+yrj//vudBV4toLXFfSMjI53qXyu0sPmxl4WwNle3hc2s56v1yj3++OP32vvV2lPZHMxaF9jXtWvXLqewwtpC2JV3lWHvPW/ePKflhLcNl8077Xtonzfsc4KxebDNC22ObZ8z7DOB9cEtT9sym4tbiG6FAbbomYXa1l7MroqzBcBs8bPBgwerqjz44IPOZxEbh/XptSvxrILY3tsqsq1XsbU0e//99515vLU5s89E1iP4jz/+cD5v2e9PeXogA6gmHgDwocmTJ9uMxvPTTz+Vuv/YY4/1dOrUqdi2Vq1aeYYOHVr4/P777/f07NnTU69ePU9cXJynY8eOngceeMCTk5NTeExeXp7n+uuv9zRs2NATFhbmvKdXRkaGZ9SoUZ6mTZt6oqKiPO3bt/c88sgjnoKCgmLvm5mZ6bnuuus89evX99SpU8dz1llneZYsWeKc66GHHio87t5773W2bdq0aY+vZ+3atZ6zzz7bGWvdunU955xzjiclJcU53l63r3PY1127du1yfZ9Kk5ub6xkzZoynTZs2ztfaokULz+jRoz1ZWVnlep/Szvf888873wv7ucTExHhq1arl6dGjh/M9zM7OLjzWvp8PPvhg4XF2zIcffui8l20rquT3w2zYsMH5/tuYbexNmjTxnHDCCZ7nnnuu8JgVK1Y4r7X3ruzvnXefnauo999/33PUUUc5v2MJCQnO79ybb75Z7Jhff/3VM3DgQE9SUpLzNdrXde6553pmzpy5z+8lAABASX/88YfnggsucOY94eHhzhwlNjbWs3DhQr+cr7xzrb3N53755RdP//79nbm0zRmPO+44z5w5c/Z4rc0vDzjgAE9ERIRznlmzZpX5Xl988YXn6KOPLpynnX766Z5FixYVO8bOYed655139jn27777zpl3du7c2Zmz29yzZcuW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rW5cwqRJk9S6dWvFxsaqV69e+vHHH4vtL89YAACA//vYNm4sTZ1asSrbO++sylEFocxM64slHXCA25/WAttWraT//Edatky65poaFdia0EnV4IdK29D59epSGNqmO4uR2Qc8AABQ9UaUaA6Xm5urnTt3Kjo62glNL7nkkkqd96efftJ//vMfde3atdj2UaNG6aOPPtI777yjunXravjw4Ro4cKC+++47Z39+fr4T2DZp0kRz5sxRamqqM4aoqCg9+OCDzjErVqxwjrnmmmv0+uuva+bMmbryyiuVnJzs9Oc1b731lm688UY9++yzTmBri63ZviVLljhBcHnGAgAAAmPhsYqyQlKqbIuEtbbA2KOPShs3uttat3ZTbZvnRbtrKtVEVNrC50KxPYKzGFlEuNJ25WrNVvfrBwAAVW/btm3FbtbT1oLNY445ptILkdk5rCfu888/r8TExMLtaWlpevHFF/X444/r+OOP16GHHqrJkyc74ez333/vHPP5559r0aJFeu2119S9e3cNGDBA48aNc6pmc3JynGMsiG3Tpo2ziNpBBx3khK2DBw/WE088Ufhe9h5XXXWVLrvsMmeRNXuNhdAvvfRSuccCAACCa+GxhATp3XelgQOralRBZMcOtwWCBbS33uoGtlZl++KL0l9/SVdeWaMDW0NoC58LxUrb6MhwdWgS7zxekEKLBAAA/Kl9+/ZOa4OSVbjlZS0HrBL2xBNPLLZ93rx5TiVv0e0dO3ZUy5YtNXfuXOe53Xfp0kWN7TrI3axCNj09XQsXLiw8puS57RjvOSzctfcqekx4eLjz3HtMecYCAAD8F9hOmFCxhceMFZSGfGCbkSGNH++Gtbao2ObNUtu20uTJ0p9/SpdfLkWFRpFg6KRqqP6etjGh9etlfW1tITK7ndIl2d/DAQBAob44WYp3JeEKmDJlin755RenPUJJ69evd9ou1KtXr9h2C2htn/eYooGtd793X1nHWLC7a9cup2LY2iyUdsyf9mGlnGMpKTs727l52fsBAADfhrXjxrkFolluNFIhzZopdNm85Kmn7HIjaetWd1v79tJdd0kXXGCTO4Wa0PuKUaWycvO1eYf7YSA+LjT+8lG0r61dhMliZAAAVJ/333+/2HPrLW99ZJ9++mkdffTRFTrXmjVrnOrcGTNmOIt/1TTjx4/XmDFj/D0MAABqbP/aoUPdq/oro3lzqXdvhZ60NOnJJyVrE7Vtm7utQwc3rB0yJCTDWq/Q/cpRJdanuX9K8uRmKzYytLpveBcjs0pbFiMDAKB6nHXWWcWe2///NmzY0Onzaj1jK8JaDmzcuFGHHHJI4TareP3mm2+cEPizzz5zWhds3769WIXrhg0bnIXHjN3/+OOPxc5r+737vPfebUWPSUhIUFxcnCIiIpxbaccUPce+xlLS6NGjncXNilbatmjRokLfIwAA4LsFx4qaODHEFh/bvt39oq2PhD02HTtKd98tnXdeiH0zShdaqRqqrZ9twY4tIRdaHtikjiLDw7R9Z65SdofXAACgahUUFBS7Wchq7QHeeOMNJSdXrF3RCSecoD/++EPz588vvB122GHOomTex1FRUZo5c2bha2zRs9WrV+vII490ntu9ncPCXy+r3LVA1hYU8x5T9BzeY7znsLYHtrBY0WPsa7Pn3mNs/77GUlJMTIwzjqI3AACw/y0Rbrih8q9PSgqxxcesmvbee92etffd5wa2NkeaMkVasMBthUBg66DSFj61zhvaZm5RTZaRkaHEpIZ7bK9z9hhFNGil7sefpbxVvxRub9o0WQv/+L2aRwkAACoiPj5enTt3Lratdu3aSkpKKtx+xRVXONWq9evXd0LP66+/3glJjzjiCGd/v379nHD24osv1sMPP+wEyHfddZezuJmFpuaaa65xKndvvfVWXX755fryyy/19ttv66OPPip8X3uPoUOHOkFxz549NWHCBGVmZuqyyy5z9tetW3efYwEAAFXvq6+kdesq99o77pDGjg2RjNL61FoLBGuF4O2rb/Ore+5xy5TDqSstidAWPpWyexEyz47dTaNrKKt2uWfKd3tsn7Fogxalpuu4YffpyLZJhdvHDqlYTz0AALB3RS/x35fHbTELH3riiScUHh6uQYMGOYt69e/fX/+2pZ53s7YGH374oa699lonQLXQ18LXsfaJbLc2bdo4Ae2oUaM0ceJENW/eXC+88IJzLq/zzjtPmzZt0j333OMEv927d9enn35abHGyfY0FAABUralTpUsuqfzrTzopBALbLVvcxcVskbGMDHdb165uWHv22YS1ZSC0RZW1RwhFjeJjtChV2rR7MTYAAOB7v/76a7mO80Wrpq+sfKYIW6Bs0qRJzm1vWrVqpY8//rjM8/bt23efX8fw4cOd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Uz+nDcJcHVXmOcLCpKlTpYEDq2nQQA0T8Mlbw4YNiz1/6KGH1LZtWx177LHFQtomTZr4YXShZc3u1gjNEuOcylD4lrfS9o91aUrPylVCbJS/hwQAQMCyP9hHR0dr+fLlToVtyX39+vVz7p944gm/jREAgGB06qnS0o//0iu6XxfqdUWowNn+sQZorO7RDzpin+do21ZaskSKiKiGAQM1VMC3RygqJydHr732mi6//PJioeHrr7/uXArXuXNnjR49Wjt3uhWhe5Odna309PRiN+wbi5BVreS6cWrToLYKPNKPf2/193AAAAho06dP16OPPrpHYGvsj/kPP/yw/ve///llbAAABKvD4//U+R9fpMU6SJfov05g+6FOVU/9oFP1cbkC29NOk5YtI7AFanylbcnJufUnu/TSSwu3XXDBBWrVqpWaNm2q33//XbfddpuWLFmiadOm7fU848eP15gxY6pp1DXH2q1uGM4iZFXniAOStGJzpr5bvlknHrznh1AAAOBKTU1Vp06d9rrf/pi/fv36ah0TAADBKuvXxZp+6Dj94JmicHmcbe/rdKeydp4OK/d5brrpnz64AEIotH3xxRc1YMAAJ6D1GjZsWOHjLl26KDk5WSeccIJzqZy1USiNVePeeOONhc+t0rZFixZVPPrgt3p3aNsqiUrbqnJMuwZ688fV+uavTf4eCgAAAc2uslq5cqWaN29e6v4VK1aofv361T4uAACCysKF+qbfOB2T8raG7A5rp+tMJ6z9VYeU+zRWVWsXPUdHV+FYgRATNO0RVq1apS+++EJXXnllmcf16tXLuV9mtfh7ERMTo4SEhGI3lD+0bVmf0LaqHNO+gSLCw7R8U6bW7P5+AwCAPfXv31933nmn0z6rtFZYd999t04++WS/jA0AgID3xx/SueeqoHMX9Ul5y6munaaz1V2/6mxNr1Bg26qVlJdHYAuEbKXt5MmT1ahRI51qHbHLMH/+fOfeKm5RNaFtC0LbKlM3LkqHtKynn1Zu09d/bdJFR7Ty95AAAAhItsjYYYcdpvbt2+u6665Tx44d5fF4tHjxYv373/92gtv/2tLXAADgH7/9Zv8nKu1uKWmVfFM1yKms/UNdK3y6116TLrywCsYJIDhC24KCAie0HTp0qCIj/xmytUB44403dMoppygpKcnpaTtq1Cj16dNHXbtW/B8b7F3azlxlZOU5j1uwEFmV6tuhkRPafrWE0BYAgL2xtghz587Vv/71L6f1lQW2xharPemkk/T000/T/goAAK9ff3XD2unTnacFCtNUDdY43a0F6lLh0zVsaP3lWWwMUKiHttYWYfXq1br88suLbY+Ojnb2TZgwQZmZmc7EfNCgQbrrrrv8NtaaXmXbMD5GcdH8q1yVjj2woR75bInmLN+s7Lx8xUTy/QYAoDRt2rTRJ598om3btmnp0qXOtnbt2tHLFgAAr19+kWwh9vffd5+HhWlqxHm6N+8uLdLeF/QsS3y8tHGjb4cJIEhD2379+hVWTxRlIe3XX3/tlzGFGvrZVp9OTROccHxTRrZ+XrlNR7dr4O8hAQAQ0BITE9WzZ09/DwMAgMDx889uWPvhh85TT3i4vm4yRNem3KU/8w6q9GkPOUSaN8+H4wQQ/AuRIUD62SbG+XsoNZ5d1mnVtuarJfz5EgAAAABQTj/+KNlaQIcf7gS2Fta+F3+ROhYs0nEpr+tPVT6w3bKFwBaoToS2KJc126i0rU59O7ihrS1GBgAAAABAmb7/XhowQOrVS/r4Yyesndf5EnUoWKyzMv6rv9Rhv05/yy0S3YeA6kVoi3JZ4620JbStFr3bNVR4mPTXhh1K2b7L38MBAAAAAASiOXOk/v2lI4+UPv3UWRlsxbGXqn3BEh224BUt1YH7/RYW2D78sE9GC6ACCG1RLvS0rV51a0WpR8tE5/GXf9IiAQAAAABQxOzZ0oknSkcfLX3+uRQZKV1+ua7qs0QHfD1Zy9Vuv9/iiCOk7GwCW8BfCG2xT3n5BVq3za32pNK2+px4UGPn/vNFG/w9FAAAAABAILDF2I8/XurTR5o50w1rr7xSWb//pTpvvagXZrX1ydscdpg0d64UHe2T0wGoBEJb7FNqWpbyCjyKjghX44RYfw8nZPTv5Ia2c5dvVnpWrr+HAwAAAADwl6++kvr2dW+zZklRUdLVVyv/z6Xq9fvziju4jTIzffNWp50m/fSTb84FoPIIbVHuRciaJ8Ypwhqtoloc0LCO2jWqo9x8j2bRIgEAAAAAQovH41bTHnusdNxxbpWtlb5ee620bJnePPZZRbZrrR9/9N1b/utf0gcf+O58ACovcj9eixDBImT7LyMjQ4lJDct1bNOmyVr4x++F1bbLNu7QZwvX68zuzap4lAAAAACAgAhrv/hCGjNG+u47d5uFtVddJd12m3YktlCzZlJ6um/ftm1badIk354TQOUR2qLci5C1qB/n76EErYKCAt0zZff/2e7D2CFHFz7u36mJJs1arq+WbFJWbr5ioyKqcJQAAAAAAL+GtbaomIW11lDWxMRIw4Y5Ya0ltYceKv3yi+/f+vTTpfff9/15AVQe7RGwT6u3uouQtaTSttp1aVZXTevGamdOvr5dutnfwwEAAAAAVEVY+8kn0pFHSief7Aa2sbHSiBHS339LTz7pBLa1avk2sI2Lc9Yw086dBLZAICK0RbkrbQltq19YWJj6dWriPLYWCQAAAACAGhTWfvSR1KuXdMop0g8/uEnqqFFuWDthgvXP065d9tlQzr0vtGsn5eW5Ye3zz7tvCSDwENpin9bS09av+nVq7Nx/sXiD8vIL/D0cAAAAAMD+hrW22lfPntJpp0k//eQmpzfdJK1YIT3+uJScXNi2wCpsfSEy0tZbkZYulSLovAcEPHraokw7svO0JTPHeUxo6x89W9dXYq0obduZqx9WbNXR7RoU7uvUpatSUlIrvMAZAAAAAMAPYa31IRg79p8+B5bIXneddPPNUqNGxQ5v0kTasME3b926tZsHAwgehLYo05rdVbb1akUpITbK38MJSZER4Tq5cxO9+eMavT8/pVhoa4FtZRY4AwAAAABUk4ICafp0N6z97Td3W5060vDh0o03Sg0bFh6akyM9+qh0111uxusL1hrXOi0ACC60R0CZVm2hn20gOL1bU+f+kwWpysmjRQIAAAAABEVYO3Wq1KOHNGiQG9haWHvHHW7Z6/jxxQLbkSOlmBjpzjt9E9gefbSUnU1gCwQrKm1DWHkurY/uOkBxvc7Twh++loYfU21jQ3G92iSpUXyMNmZk65u/NunEg90+twAAAACAAA1rx42TFixwt8XHuyWvtshY/fp7vKRxY2njRt+8vbXH3b5dio72zfkA+AehbQgrz6X1Mxdv0IKUdGVuWF1t48KeIsLDdFrXpnrpuxV6/7cUQlsAAAAACDT5+dI777hh7aJF7ra6dd2w1spoExNLfZktCmY5ry9cf7305JO+ORcA/yK0RZnSduU69wXpPup+jko7o7sb2s5YtEE7c/JUK5r/fAEAAAAgIMLat95yw9o//3S31avnBrUW2NrjUlj/WmuH4AvWCuHLL6muBWoSUh+Uafvu0HbH+hVKTPqn186+ZGSkV+GoQlO35nWd3sKrt+7UF4s36ozdfW4BAAAAAH6QlydNmSLdf7+0ZIm7zapprQXCDTe4VbZ7yXitxe177/lmGDfd5C5eBqBmIbTFXuUVFCgjK895nLM1RQ+8W3YrhaJuGtC5CkcWmsLCwnR6t2RNmrVc789PIbQFAAAAAH+FtW+84Ya1S5e626xP7Y03uv0JEhL2+lJrdXvOOb4byttv+/Z8AAIHoS32Kn2XG9hGRYSpYGeav4cTMjIyMvZa1Rye2Ezxgx/QjAXrVL/pYCqaAQAAAKC65OZKr78uPfCAtGyZuy0pyS11HT7cXWysDHbY44/7ZigNGkjr17v9cAHUTOH+HgAC1/ZdOc593bgofw8lpBQUFDgLxJV2u+uZt9UwPkZhEZE64/63VVDg8fdwAQCoMcaPH6/DDz9c8fHxatSokc466ywt8V7uultWVpauu+46JSUlqU6dOho0aJA2bCje+3/16tU69dRTVatWLec8t9xyi/KsKquIr776SocccohiYmLUrl07vfzyy3uMZ9KkSWrdurViY2PVq1cv/fjjjxUeCwDAR2Htiy9KHTtKl13mBraWmj70kLRypTR6dJmBbVqa2ynBV4FtbKy0aROBLVDTEdpir9J2uv1s68XRyTyQHJzsXmqzKJUqWwAAfOnrr792QtDvv/9eM2bMUG5urvr166fMzMzCY0aNGqUPPvhA77zzjnN8SkqKBg4cWLg/Pz/fCWxzcnI0Z84cvfLKK04ge8899xQes2LFCueY4447TvPnz9fIkSN15ZVX6rPPPis85q233tKNN96oe++9V7/88ou6deum/v37a+PGjeUeCwBgP9lKYc8/Lx14oHTlldLff0sNG0oPP2z/mEu33SbVqVPmKQ44wF2HLN1HH99at5Z27fLNuQAENtojYK/Sdi9CVrcWlbaBpEPjeM1eukkbM7IV1aClv4cDAECN8emnnxZ7bmGrVcrOmzdPffr0UVpaml588UW98cYbOv74451jJk+erIMOOsgJeo844gh9/vnnWrRokb744gs1btxY3bt317hx43TbbbfpvvvuU3R0tJ599lm1adNGjz32mHMOe/23336rJ554wglmzeOPP66rrrpKl1lFl+S85qOPPtJLL72k22+/vVxjAQDsR1g7ebJdgiGtWuVua9xYuvVW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XbSwsDC1Gqs17XS2Ptu0aZP6zH377be1AwcOaHPmzFHP7auvvrLsw8//q8nK0/LavfTSS1fdxvcYkX3asGGDNnXqVDX+TUxM1JYvX661bdtWq1mzppadnW108+zK8ePHtVq1ammdO3dW5wuPlenmyHcyeW+OHTtW8/f3t3xvk+9w5Lzf4W0tM6CyzxSobLIGZ+H0oa2QwZx8AfL09NRatWqlBniOYOXKleqDt/g2cOBAdbvJZNJef/119aVbfunJIGzfvn1F7uPs2bPqS7oMJAIDA7VBgwZdNZDYsWOHdtttt6n7qFKlivoCXtx3332n1alTR/Vxw4YNtV9++aXI7da0pbyV1FeyzZo1y7KPhAjPPPOMFhISor5833PPPVcNVuVLQY8ePTQfHx8VLEnglJeXd9Vr07RpU9UfNWrUKPIY1r4vrWlLeXv88ce1atWqqTZKQCGvW+EPUfZX6UNb9tnVHnzwQS0qKkq1Uz5j5PLBgwdL1U5n67OffvpJhYjyeVqvXj3t008/LXI7P/+vtnTpUvWZX9Jj8z1GZJ/kS16nTp20SpUqqc+X6tWrqz98SOhIpSOfV9caK9PNke9kJfWn/K4g5/0Ob2uZAZV9pkBlkzU4Cxf5n9GzfYmIiIiIiIiIiIhIx0JERERERERERERERDaEoS0RERERERERERGRDWFoS0RERERERERERGRDGNoSERERERERERER2RCGtkREREREREREREQ2hKEtERERERERERERkQ1haEtERERERERERERkQxjaEhEREREREREREdkQhrZERDZi9uzZCA4OLvfHSUxMhIuLC7Zv317uj0VERERE5eePP/5Q47oLFy7Ankibf/zxxzK7v+rVq2PKlCmwV8XH5/b6uhJR2WJoS0RURlJSUjBkyBDExsbCy8sLkZGR6NatG9auXVtujykDVBnQyebn54fmzZtj3rx51/2ZmJgYnDp1Co0aNSq3dhERERHRP2Me411re+ONN2DrpI1Nmza96noZi/bo0QPO6LHHHkPfvn2LXMfxORGVxL3Ea4mIqNTuvfde5Obm4osvvkCNGjVw+vRpLF++HGfPni3Xx33zzTcxePBgpKen4/3338eDDz6IKlWqoG3btlftK+3z9PRUgTIRERER2S4J8cy+/fZbjB49Gvv27bNc5+/vjy1bthjSNvOY8mZxLFqUm5sb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dV5lhqy5Bq+ZzCI2LxgmZCatzGI1u5nx/M32SXHSTnlNrjfml9ehS5cuapNJIxLWSs3dksJ6IrIPXIiMiKgMnD17Vq2W+9VXX6lDl2SAN2/ePFUeQRZ2kAGWhKJTp05VAagsTDB9+vTr3qf8hfx///ufmhkhix3I4Wlz585VpRDKkixgIIPS/v37q0UMDhw4oNpnXnVYHl8OA5NFF/bv34+EhATMmjVLrZ5LRERERLbtRmNKCfni4+PVH+hltuamTZvUwmWyONj1ymzJz7Vp0wZ9+/ZVszslSF23bp1aFE3GlELCXBkXSwmE1NTUEhfsHTBgACIjI9X9SEArY2VZ8Gz9+vXq9tq1a1sWP5MyAQ899JBlFrG1ZBE2KSEmkymktMEzzzyjQunCZCwvY2ApdSbj3YEDBxY5suxmxvMlkT6R7wsy1pY+KTyb91qkHJr0rYzbpR9kvL5w4ULLQmQ///yzGqvLbUePHlWvt/RR3bp1S90+IrIdDG2JiMqAlCaQ8gGTJ09Wf8Fv1KiRKo8gdWA/+ugjNGnSRIWcEyZMULdJPSoJQq+nW7duagAmg2CpJXbrrbeq+5d6VWVJ6pDJX+HNK/e2aNFClUMwz7qVEg8y+0GCWhnQyz6y+m5cXFyZtoOIiIiIyt6NxpRy+L4EgCEhIWocK2Gs1Eb99ttvr3u/8nOLFy9WPzNo0CDUqVNHTQKQ0FCO1jKv+SD1VTt16qRmsn7zzTclzjyVtoWHh6Nnz55qvCkBqzkwlTG0tK1t27a4++671fMpPEPWGiNGjMAjjzyiglgJmgMCAiwzd81GjRqlxrlSAkHWh5AQuXBt2psZz5dEvh9ImCqBuPSJBNU3IrORV61apSZQyFoUUgNYwng5Ik7IrFoJtiV4lpnTEiZLXzds2LDU7SMi2+Eiq5EZ3QgiIiIiIiIioooiJRdktq3MviUiskWcaUtERERERERERERkQxjaEhEREREREREREdkQlkcgIiIiIiIiIiIisiGcaUtERERERERERERkQxjaEhEREREREREREdkQhrZERERERERERERENoShLREREREREREREZENYWhLREREREREREREZEMY2hIRERERERERERHZEIa2RERERERERERERDaEoS0RERERERERERGRDWFoS0RERERERERERATb8f8Bybg00C1hZpAAAAAASUVORK5CYII='}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Displayed on the user's machine.(np.float64(0.8696714665902145), np.float64(3.2061412312022114e-33))""}, {'role': 'assistant', 'type': 'message', 'content': 'The Shapiro-Wilk test statistic is approximately 0.870, with a p-value of \\(3.206 \\times 10^{-33}\\). This very low p-value indicates that ""SalePrice"" is not normally distributed. \n\nThe histogram shows a right-skewed distribution, and the Q-Q plot indicates deviations from normality, especially in the tails. If you need further analysis, feel free to ask!'}]"
20,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Define the 'PriceRange' variable based on 'SalePrice'\ndef categorize_price_range(price):\n    if price < 100000:\n        return 'Low'\n    elif price < 300000:\n        return 'Medium'\n    else:\n        return 'High'\n\n# Apply the function to create 'PriceRange'\ndf['PriceRange'] = df['SalePrice'].apply(categorize_price_range)\n\n# Calculate the average 'SalePrice' for the 'Medium' price range\nmedium_price_avg = df[df['PriceRange'] == 'Medium']['SalePrice'].mean()\n\nmedium_price_avg""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(171941.72867587328)'}, {'role': 'assistant', 'type': 'message', 'content': 'The average ""SalePrice"" among houses in the ""Medium"" price range is approximately $171,941.729. If there\'s anything else you\'d like to do, just let me know!'}]"
21,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Get the value counts for the 'PriceRange' variable\nprice_range_counts = df['PriceRange'].value_counts()\n\nprice_range_counts""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'PriceRange\nMedium    1231\nHigh       115\nLow        114\nName: count, dtype: int64'}, {'role': 'assistant', 'type': 'message', 'content': 'The value counts for ""PriceRange"" are as follows:\n\n- **Medium:** 1,231\n- **High:** 115\n- **Low:** 114\n\nLet me know if you need further analysis or assistance!'}]"
22,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Define features and target variable\nX_train_features = train_df[['TotalSF', 'GarageYrBlt', 'GarageArea']]\nX_test_features = test_df[['TotalSF', 'GarageYrBlt', 'GarageArea']]\ny_train = train_df['SalePrice']\ny_test = test_df['SalePrice']\n\n# Fit the linear regression model\nlinear_model_features = LinearRegression().fit(X_train_features, y_train)\n\n# Calculate the R-squared value for the train set\ntrain_r_squared_features = linear_model_features.score(X_train_features, y_train)\n\n# Make predictions on the test set and calculate RMSE\npredictions_features = linear_model_features.predict(X_test_features)\ntest_rmse_features = np.sqrt(mean_squared_error(y_test, predictions_features))\n\ntrain_r_squared_features, test_rmse_features""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(0.641984937755723, np.float64(48711.91785460191))'}, {'role': 'assistant', 'type': 'message', 'content': 'The R-squared value for the training dataset is approximately 0.642, indicating that about 64.2% of the variance in ""SalePrice"" is explained by the model. The test RMSE is approximately $48,711.918. If you need more assistance, just let me know!'}]"
23,"[{'role': 'assistant', 'type': 'message', 'content': 'Let\'s compute the mean and standard deviation for the ""alcohol"" feature. According to the rules, for exploratory analysis, we should consider the entire dataset, and we need to temporarily drop rows with missing values in the ""alcohol"" column before calculating these statistics. Let\'s proceed with this calculation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Drop rows with missing values in the 'alcohol' column\ndataset_non_missing = wine_data.dropna(subset=['alcohol'])\n\n# Calculate mean and standard deviation\nalcohol_mean = dataset_non_missing['alcohol'].mean()\nalcohol_std = dataset_non_missing['alcohol'].std()\nalcohol_mean, alcohol_std""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(13.00061797752809), np.float64(0.8118265380058575))'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean of the ""alcohol"" content in the dataset is approximately 13.001, and the standard deviation is approximately 0.812. If you have any more questions or need further analysis, feel free to ask!'}]"
24,"[{'role': 'assistant', 'type': 'message', 'content': 'Similarly, we\'ll calculate the mean and standard deviation for the ""malic_acid"" feature, ensuring that we temporarily drop any rows with missing values in this column first. Let\'s proceed with this calculation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Drop rows with missing values in the 'malic_acid' column\ndataset_non_missing_malic_acid = wine_data.dropna(subset=['malic_acid'])\n\n# Calculate mean and standard deviation\nmalic_acid_mean = dataset_non_missing_malic_acid['malic_acid'].mean()\nmalic_acid_std = dataset_non_missing_malic_acid['malic_acid'].std()\nmalic_acid_mean, malic_acid_std""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(2.3363483146067416), np.float64(1.1171460976144627))'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean of the ""malic_acid"" content in the dataset is approximately 2.336, and the standard deviation is approximately 1.117. If there\'s anything else you\'d like to explore or analyze, just let me know!'}]"
25,"[{'role': 'assistant', 'type': 'message', 'content': 'To calculate the skewness and kurtosis of the ""alcohol"" feature, I\'ll use the entire dataset and temporarily drop rows with missing values in the ""alcohol"" column before performing the calculations. Let\'s proceed with these computations.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import skew, kurtosis\n\n# Calculate skewness and kurtosis for the 'alcohol' column\nalcohol_skewness = skew(dataset_non_missing['alcohol'])\nalcohol_kurtosis = kurtosis(dataset_non_missing['alcohol'])\nalcohol_skewness, alcohol_kurtosis""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(-0.05104747165391963), np.float64(-0.8622600987701743))'}, {'role': 'assistant', 'type': 'message', 'content': 'The skewness of the ""alcohol"" feature is approximately -0.051, indicating a slight left skew. The kurtosis is approximately -0.862, which suggests that the distribution is slightly platykurtic (flatter than a normal distribution). Let me know if you have any more questions or need further analysis!'}]"
26,"[{'role': 'assistant', 'type': 'message', 'content': 'To calculate the correlation between ""alcohol"" and ""malic_acid"", I\'ll use the entire dataset and temporarily drop any rows with missing values in either of these columns before calculating the correlation. Let\'s proceed with this computation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Drop rows with missing values in 'alcohol' or 'malic_acid'\ndataset_non_missing_alcohol_malic_acid = wine_data.dropna(subset=['alcohol', 'malic_acid'])\n\n# Calculate the correlation between 'alcohol' and 'malic_acid'\nalcohol_malic_acid_correlation = dataset_non_missing_alcohol_malic_acid['alcohol'].corr(dataset_non_missing_alcohol_malic_acid['malic_acid'])\nalcohol_malic_acid_correlation""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.09439694091041399)'}, {'role': 'assistant', 'type': 'message', 'content': 'The correlation between ""alcohol"" and ""malic_acid"" is approximately 0.094. This indicates a very weak positive linear relationship between the two features. If there\'s anything else you\'d like to explore, feel free to ask!'}]"
27,"[{'role': 'assistant', 'type': 'message', 'content': 'To fit a logistic regression model for predicting ""wine_class"" using the features ""alcohol"", ""malic_acid"", and ""flavanoids"", we will:\n\n1. Prepare the data by temporarily dropping any rows with missing values in the selected features from both the train and test sets.\n2. Scale the features using a `StandardScaler`, fitting on the train set and transforming both train and test sets.\n3. Fit a logistic regression model on the train set.\n4. Predict the probabilities on the test set and compute the one-vs-one Area Under the Receiver Operating Characteristic curve (AUROC).\n\nLet\'s proceed with these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LogisticRegression\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.multiclass import OneVsOneClassifier\n\n# Features and target variable\nfeatures = ['alcohol', 'malic_acid', 'flavanoids']\ntarget = 'wine_class'\n\n# Temporarily drop rows with missing values in selected features and target\ndef drop_missing_values(df, columns):\n    return df.dropna(subset=columns)\n\ntrain_set_clean = drop_missing_values(train_set, features + [target])\ntest_set_clean = drop_missing_values(test_set, features + [target])\n\n# Scale the features\nscaler = StandardScaler()\nX_train = scaler.fit_transform(train_set_clean[features])\nX_test = scaler.transform(test_set_clean[features])\n\n# Target values\ny_train = train_set_clean[target]\ny_test = test_set_clean[target]\n\n# Fit logistic regression model with one-vs-one strategy\nclf = OneVsOneClassifier(LogisticRegression(random_state=42))\nclf.fit(X_train, y_train)\n\n# Predict probabilities on the test set\nprobs_test = clf.decision_function(X_test)\n\n# Compute one-vs-one AUROC for each pair of classes\nauroc_ovo = roc_auc_score(y_test, probs_test, multi_class='ovo')\nauroc_ovo""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[390], line 68\n     66 pass\n     67 print(\'##active_line34##\')\n---> 68 auroc_ovo = roc_auc_score(y_test, probs_test, multi_class=\'ovo\')\n     69 print(\'##active_line35##\')\n     70 auroc_ovo\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/sklearn/utils/_param_validation.py:216, in validate_params.<locals>.decorator.<locals>.wrapper(*args, **kwargs)\n    210 try:\n    211     with config_context(\n    212         skip_parameter_validation=(\n    213             prefer_skip_nested_validation or global_skip_validation\n    214         )\n    215     ):\n--> 216         return func(*args, **kwargs)\n    217 except InvalidParameterError as e:\n    218     # When the function is just a wrapper around an estimator, we allow\n    219     # the function to delegate validation to the estimator, but we replace\n    220     # the name of the estimator by the name of the function in the error\n    221     # message to avoid confusion.\n    222     msg = re.sub(\n    223         r""parameter of \\w+ must be"",\n    224         f""parameter of {func.__qualname__} must be"",\n    225         str(e),\n    226     )\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/sklearn/metrics/_ranking.py:635, in roc_auc_score(y_true, y_score, average, sample_weight, max_fpr, multi_class, labels)\n    633     if multi_class == ""raise"":\n    634         raise ValueError(""multi_class must be in (\'ovo\', \'ovr\')"")\n--> 635     return _multiclass_roc_auc_score(\n    636         y_true, y_score, labels, multi_class, average, sample_weight\n    637     )\n    638 elif y_type == ""binary"":\n    639     labels = np.unique(y_true)\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/sklearn/metrics/_ranking.py:708, in _multiclass_roc_auc_score(y_true, y_score, labels, multi_class, average, sample_weight)\n    706 # validation of the input y_score\n    707 if not np.allclose(1, y_score.sum(axis=1)):\n--> 708     raise ValueError(\n    709         ""Target scores need to be probabilities for multiclass ""\n    710         ""roc_auc, i.e. they should sum up to 1.0 over classes""\n    711     )\n    713 # validation for multiclass parameter specifications\n    714 average_options = (""macro"", ""weighted"", None)\n\nValueError: Target scores need to be probabilities for multiclass roc_auc, i.e. they should sum up to 1.0 over classes'}, {'role': 'assistant', 'type': 'message', 'content': ""It seems we attempted to use raw decision function scores instead of probabilities for computing multi-class AUROC, which requires probability estimates that sum up to 1 for each instance. Let's adjust the code to use probabilities and then compute the one-vs-one AUROC.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Predict probabilities on the test set\nprobs_test = clf.predict_proba(X_test)\n\n# Compute one-vs-one AUROC for each pair of classes\nauroc_ovo = roc_auc_score(y_test, probs_test, multi_class='ovo')\nauroc_ovo""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[391], line 4\n      2 pass\n      3 print('##active_line2##')\n----> 4 probs_test = clf.predict_proba(X_test)\n      5 print('##active_line3##')\n      6 pass\n\nAttributeError: 'OneVsOneClassifier' object has no attribute 'predict_proba'""}, {'role': 'assistant', 'type': 'message', 'content': ""The `OneVsOneClassifier` does not support the `predict_proba` method. Instead, we should directly fit a logistic regression model with **OneVsRestClassifier** that supports multi-class classification probabilities. Let's implement this approach.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.multiclass import OneVsRestClassifier\n\n# Fit logistic regression model with one-vs-rest strategy\nclf = OneVsRestClassifier(LogisticRegression(random_state=42))\nclf.fit(X_train, y_train)\n\n# Predict probabilities on the test set\nprobs_test = clf.predict_proba(X_test)\n\n# Compute one-vs-one AUROC for each pair of classes\nauroc_ovo = roc_auc_score(y_test, probs_test, multi_class='ovo')\nauroc_ovo""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.9985119047619048)'}, {'role': 'assistant', 'type': 'message', 'content': 'The one-vs-one AUROC for the logistic regression model predicting ""wine_class"" from ""alcohol"", ""malic_acid"", and ""flavanoids"" is approximately 0.999. This indicates an excellent ability of the model to distinguish between the classes. If you have any more questions or requests, feel free to ask!'}]"
28,"[{'role': 'assistant', 'type': 'message', 'content': 'To engineer the new variable ""meaningless"" defined as (""proline"" - ""alcohol"" * ""malic_acid""), we\'ll add this variable to the dataset and then calculate its median value. We\'ll use the entire dataset and temporarily drop any rows with missing values in the involved columns before calculating the median. Let\'s proceed with these steps.'}]"
29,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the third largest value of ""alcohol"", we\'ll consider the entire dataset, temporarily drop any rows with missing values in the ""alcohol"" column, and then sort the values to identify the third largest one. Let\'s proceed with this calculation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Sort the 'alcohol' values in descending order and get the third largest\nthird_largest_alcohol = dataset_non_missing['alcohol'].nlargest(3).iloc[-1]\nthird_largest_alcohol""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(14.39)'}, {'role': 'assistant', 'type': 'message', 'content': 'The third largest value of ""alcohol"" in the dataset is approximately 14.390. Let me know if there\'s anything else you need!'}]"
30,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Count the occurrences of each class in 'wine_class'\nwine_class_counts = wine_data['wine_class'].value_counts()\nwine_class_counts""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'wine_class\n1    71\n0    59\n2    48\nName: count, dtype: int64'}, {'role': 'assistant', 'type': 'message', 'content': 'The dataset contains the following number of samples for each ""wine_class"":\n\n- Class 0: 59 samples\n- Class 1: 71 samples\n- Class 2: 48 samples\n\nIf you have any further questions or need additional analysis, feel free to ask!'}]"
31,"[{'role': 'assistant', 'type': 'message', 'content': 'Let\'s proceed to fit a linear regression model to predict the engineered ""meaningless"" variable using ""flavanoids"". We\'ll follow these steps:\n\n1. Engineer the ""meaningless"" variable using the formula (""proline"" - ""alcohol"" * ""malic_acid"") in both train and test sets.\n2. Temporarily drop any rows with missing values in the required columns.\n3. Fit a linear regression model on the train set.\n4. Predict on the test set and calculate the R-squared value to assess how well the model fits the test data.\n\nLet\'s execute these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import r2_score\n\n# Add the 'meaningless' variable to both train and test sets\ndef add_meaningless_variable(df):\n    return df.assign(meaningless=df['proline'] - df['alcohol'] * df['malic_acid'])\n\ntrain_set = add_meaningless_variable(train_set)\ntest_set = add_meaningless_variable(test_set)\n\n# Drop rows with missing values in 'meaningless' and 'flavanoids'\ntrain_set_clean = drop_missing_values(train_set, ['meaningless', 'flavanoids'])\ntest_set_clean = drop_missing_values(test_set, ['meaningless', 'flavanoids'])\n\n# Features and target\nX_train = train_set_clean[['flavanoids']]\ny_train = train_set_clean['meaningless']\nX_test = test_set_clean[['flavanoids']]\ny_test = test_set_clean['meaningless']\n\n# Fit linear regression model\nlin_reg = LinearRegression()\nlin_reg.fit(X_train, y_train)\n\n# Predict on the test set\npredictions = lin_reg.predict(X_test)\n\n# Calculate R-squared\nr_squared = r2_score(y_test, predictions)\nr_squared""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '0.2999825999103126'}, {'role': 'assistant', 'type': 'message', 'content': 'The test R-squared for regressing the ""meaningless"" variable on ""flavanoids"" is approximately 0.300. This indicates that the model explains about 30% of the variance in the ""meaningless"" variable based on ""flavanoids"" in the test set. Let me know if you need further analysis or have any other questions!'}]"
32,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the average and standard deviation of the mean radius, I will calculate these statistics over the entire dataset, while temporarily dropping any rows with missing values for the ""mean radius"" variable. Let\'s proceed with this calculation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Temporary drop rows with missing values in 'mean radius' column\ndata_no_missing = data.dropna(subset=['mean radius'])\n\n# Calculate mean and standard deviation\nmean_radius_avg = data_no_missing['mean radius'].mean()\nmean_radius_std = data_no_missing['mean radius'].std()\n\nround(mean_radius_avg, 3), round(mean_radius_std, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(14.127), np.float64(3.524))'}, {'role': 'assistant', 'type': 'message', 'content': 'The average mean radius is 14.127, and the standard deviation is 3.524. Let me know if you need further analysis!'}]"
33,"[{'role': 'assistant', 'type': 'message', 'content': ""To compute the correlation between the mean radius and the breast cancer indicator variable, I first need to identify which column in the dataset represents the breast cancer indicator. I will inspect the first few rows of the dataset to find the appropriate column. Let's do that first.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': '# Display the first few rows to identify the breast cancer indicator column\ndata_no_missing.head()'}, {'role': 'computer', 'type': 'code', 'format': 'html', 'content': '<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=""1"" class=""dataframe"">\n  <thead>\n    <tr style=""text-align: right;"">\n      <th></th>\n      <th>Unnamed: 0</th>\n      <th>mean radius</th>\n      <th>mean texture</th>\n      <th>mean perimeter</th>\n      <th>mean area</th>\n      <th>mean smoothness</th>\n      <th>mean compactness</th>\n      <th>mean concavity</th>\n      <th>mean concave points</th>\n      <th>mean symmetry</th>\n      <th>...</th>\n      <th>worst texture</th>\n      <th>worst perimeter</th>\n      <th>worst area</th>\n      <th>worst smoothness</th>\n      <th>worst compactness</th>\n      <th>worst concavity</th>\n      <th>worst concave points</th>\n      <th>worst symmetry</th>\n      <th>worst fractal dimension</th>\n      <th>breast_cancer_yn</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0</td>\n      <td>17.99</td>\n      <td>10.38</td>\n      <td>122.80</td>\n      <td>1001.0</td>\n      <td>0.11840</td>\n      <td>0.27760</td>\n      <td>0.3001</td>\n      <td>0.14710</td>\n      <td>0.2419</td>\n      <td>...</td>\n      <td>17.33</td>\n      <td>184.60</td>\n      <td>2019.0</td>\n      <td>0.1622</td>\n      <td>0.6656</td>\n      <td>0.7119</td>\n      <td>0.2654</td>\n      <td>0.4601</td>\n      <td>0.11890</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>1</td>\n      <td>20.57</td>\n      <td>17.77</td>\n      <td>132.90</td>\n      <td>1326.0</td>\n      <td>0.08474</td>\n      <td>0.07864</td>\n      <td>0.0869</td>\n      <td>0.07017</td>\n      <td>0.1812</td>\n      <td>...</td>\n      <td>23.41</td>\n      <td>158.80</td>\n      <td>1956.0</td>\n      <td>0.1238</td>\n      <td>0.1866</td>\n      <td>0.2416</td>\n      <td>0.1860</td>\n      <td>0.2750</td>\n      <td>0.08902</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>2</td>\n      <td>19.69</td>\n      <td>21.25</td>\n      <td>130.00</td>\n      <td>1203.0</td>\n      <td>0.10960</td>\n      <td>0.15990</td>\n      <td>0.1974</td>\n      <td>0.12790</td>\n      <td>0.2069</td>\n      <td>...</td>\n      <td>25.53</td>\n      <td>152.50</td>\n      <td>1709.0</td>\n      <td>0.1444</td>\n      <td>0.4245</td>\n      <td>0.4504</td>\n      <td>0.2430</td>\n      <td>0.3613</td>\n      <td>0.08758</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>3</td>\n      <td>11.42</td>\n      <td>20.38</td>\n      <td>77.58</td>\n      <td>386.1</td>\n      <td>0.14250</td>\n      <td>0.28390</td>\n      <td>0.2414</td>\n      <td>0.10520</td>\n      <td>0.2597</td>\n      <td>...</td>\n      <td>26.50</td>\n      <td>98.87</td>\n      <td>567.7</td>\n      <td>0.2098</td>\n      <td>0.8663</td>\n      <td>0.6869</td>\n      <td>0.2575</td>\n      <td>0.6638</td>\n      <td>0.17300</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>4</td>\n      <td>20.29</td>\n      <td>14.34</td>\n      <td>135.10</td>\n      <td>1297.0</td>\n      <td>0.10030</td>\n      <td>0.13280</td>\n      <td>0.1980</td>\n      <td>0.10430</td>\n      <td>0.1809</td>\n      <td>...</td>\n      <td>16.67</td>\n      <td>152.20</td>\n      <td>1575.0</td>\n      <td>0.1374</td>\n      <td>0.2050</td>\n      <td>0.4000</td>\n      <td>0.1625</td>\n      <td>0.2364</td>\n      <td>0.07678</td>\n      <td>0</td>\n    </tr>\n  </tbody>\n</table>\n<p>5 rows  32 columns</p>\n</div>'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Displayed on the user's machine.""}, {'role': 'assistant', 'type': 'message', 'content': 'The breast cancer indicator variable is represented by the column `breast_cancer_yn`. Now, I will compute the correlation between the `mean radius` and `breast_cancer_yn`.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Compute correlation between 'mean radius' and 'breast_cancer_yn'\ncorrelation = data_no_missing[['mean radius', 'breast_cancer_yn']].corr().iloc[0, 1]\nround(correlation, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(-0.73)'}, {'role': 'assistant', 'type': 'message', 'content': 'The correlation between the mean radius and the breast cancer indicator variable is -0.730. If you need further assistance, feel free to ask!'}]"
34,"[{'role': 'assistant', 'type': 'message', 'content': ""To determine if there is a significant difference in the mean radius between individuals with and without breast cancer, I will perform an independent t-test. First, I will ensure any rows with missing values in the relevant columns are temporarily removed. Let's conduct this analysis.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import ttest_ind\n\n# Separate the mean radius values by breast cancer indicator\ngroup_with_cancer = data_no_missing[data_no_missing['breast_cancer_yn'] == 1]['mean radius']\ngroup_without_cancer = data_no_missing[data_no_missing['breast_cancer_yn'] == 0]['mean radius']\n\n# Perform t-test to compare the means\nt_stat, p_value = ttest_ind(group_with_cancer, group_without_cancer, nan_policy='omit')\nround(t_stat, 3), round(p_value, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(-25.436), np.float64(0.0))'}, {'role': 'assistant', 'type': 'message', 'content': 'The t-test statistic is -25.436, and the p-value is less than 0.001. This indicates a highly significant difference in mean radius between individuals with and without breast cancer. Let me know if you have any other questions!'}]"
35,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if there is a significant difference in the area error between individuals with and without breast cancer, I will perform another independent t-test. Let\'s perform the analysis on the ""area error"" variable.'}]"
36,"[{'role': 'assistant', 'type': 'message', 'content': ""First, I will perform min-max scaling on the `mean radius` feature using the train dataset and then apply the same transformation to the test dataset. After scaling, I'll perform linear regression to predict the breast cancer indicator based on the scaled mean radius and report the coefficient. Let's start by scaling the mean radius.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.preprocessing import MinMaxScaler\n\n# Initialize the MinMaxScaler\nscaler = MinMaxScaler()\n\n# Fit the scaler on the training data and transform both train and test data\ntrain_data_scaled = train_data.copy()\ntest_data_scaled = test_data.copy()\n\ntrain_data_scaled['mean radius'] = scaler.fit_transform(train_data[['mean radius']])\ntest_data_scaled['mean radius'] = scaler.transform(test_data[['mean radius']])\n\n# Display the first few rows of the scaled train_data for verification\ntrain_data_scaled.head()""}, {'role': 'computer', 'type': 'code', 'format': 'html', 'content': '<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=""1"" class=""dataframe"">\n  <thead>\n    <tr style=""text-align: right;"">\n      <th></th>\n      <th>Unnamed: 0</th>\n      <th>mean radius</th>\n      <th>mean texture</th>\n      <th>mean perimeter</th>\n      <th>mean area</th>\n      <th>mean smoothness</th>\n      <th>mean compactness</th>\n      <th>mean concavity</th>\n      <th>mean concave points</th>\n      <th>mean symmetry</th>\n      <th>...</th>\n      <th>worst texture</th>\n      <th>worst perimeter</th>\n      <th>worst area</th>\n      <th>worst smoothness</th>\n      <th>worst compactness</th>\n      <th>worst concavity</th>\n      <th>worst concave points</th>\n      <th>worst symmetry</th>\n      <th>worst fractal dimension</th>\n      <th>breast_cancer_yn</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>68</th>\n      <td>68</td>\n      <td>0.065527</td>\n      <td>17.33</td>\n      <td>58.79</td>\n      <td>250.5</td>\n      <td>0.10660</td>\n      <td>0.14130</td>\n      <td>0.31300</td>\n      <td>0.04375</td>\n      <td>0.2111</td>\n      <td>...</td>\n      <td>22.65</td>\n      <td>65.50</td>\n      <td>324.7</td>\n      <td>0.14820</td>\n      <td>0.43650</td>\n      <td>1.25200</td>\n      <td>0.17500</td>\n      <td>0.4228</td>\n      <td>0.11750</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>181</th>\n      <td>181</td>\n      <td>0.656203</td>\n      <td>26.57</td>\n      <td>142.70</td>\n      <td>1311.0</td>\n      <td>0.11410</td>\n      <td>0.28320</td>\n      <td>0.24870</td>\n      <td>0.14960</td>\n      <td>0.2395</td>\n      <td>...</td>\n      <td>33.48</td>\n      <td>176.50</td>\n      <td>2089.0</td>\n      <td>0.14910</td>\n      <td>0.75840</td>\n      <td>0.67800</td>\n      <td>0.29030</td>\n      <td>0.4098</td>\n      <td>0.12840</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>63</th>\n      <td>63</td>\n      <td>0.072579</td>\n      <td>13.86</td>\n      <td>59.20</td>\n      <td>260.9</td>\n      <td>0.07721</td>\n      <td>0.08751</td>\n      <td>0.05988</td>\n      <td>0.02180</td>\n      <td>0.2341</td>\n      <td>...</td>\n      <td>19.23</td>\n      <td>65.59</td>\n      <td>310.1</td>\n      <td>0.09836</td>\n      <td>0.16780</td>\n      <td>0.13970</td>\n      <td>0.05087</td>\n      <td>0.3282</td>\n      <td>0.08490</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>248</th>\n      <td>248</td>\n      <td>0.144914</td>\n      <td>25.22</td>\n      <td>68.01</td>\n      <td>347.0</td>\n      <td>0.09657</td>\n      <td>0.07234</td>\n      <td>0.02379</td>\n      <td>0.01615</td>\n      <td>0.1897</td>\n      <td>...</td>\n      <td>35.19</td>\n      <td>77.98</td>\n      <td>455.7</td>\n      <td>0.14990</td>\n      <td>0.13980</td>\n      <td>0.11250</td>\n      <td>0.06136</td>\n      <td>0.3409</td>\n      <td>0.08147</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>60</th>\n      <td>60</td>\n      <td>0.121407</td>\n      <td>14.88</td>\n      <td>64.55</td>\n      <td>311.9</td>\n      <td>0.11340</td>\n      <td>0.08061</td>\n      <td>0.01084</td>\n      <td>0.01290</td>\n      <td>0.2743</td>\n      <td>...</td>\n      <td>17.45</td>\n      <td>69.86</td>\n      <td>368.6</td>\n      <td>0.12750</td>\n      <td>0.09866</td>\n      <td>0.02168</td>\n      <td>0.02579</td>\n      <td>0.3557</td>\n      <td>0.08020</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n<p>5 rows  32 columns</p>\n</div>'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Displayed on the user's machine.""}, {'role': 'assistant', 'type': 'message', 'content': ""The `mean radius` has been successfully scaled using Min-Max scaling. Now, let's perform linear regression to regress the breast cancer indicator on the scaled mean radius and report the coefficient.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\n\n# Initialize and fit the linear regression model\nX_train = train_data_scaled[['mean radius']]\ny_train = train_data_scaled['breast_cancer_yn']\n\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Get the coefficient for mean radius\nmean_radius_coefficient = model.coef_[0]\nround(mean_radius_coefficient, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(-2.006)'}, {'role': 'assistant', 'type': 'message', 'content': 'The coefficient for the scaled mean radius in the linear regression model is -2.006. If you have any more questions or need further assistance, feel free to ask!'}]"
37,"[{'role': 'assistant', 'type': 'message', 'content': ""I will standard scale the `mean area` using the training dataset and apply the same transformation to the test dataset. After scaling, I'll perform linear regression to predict the breast cancer indicator on the scaled mean area and report the coefficient.\n\nLet's start by standard scaling the `mean area`.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.preprocessing import StandardScaler\n\n# Initialize the StandardScaler\nstandard_scaler = StandardScaler()\n\n# Fit the scaler on the training data and transform both train and test data\ntrain_data_scaled['mean area'] = standard_scaler.fit_transform(train_data[['mean area']])\ntest_data_scaled['mean area'] = standard_scaler.transform(test_data[['mean area']])\n\n# Display the first few rows of the scaled train_data for verification\ntrain_data_scaled.head()""}, {'role': 'computer', 'type': 'code', 'format': 'html', 'content': '<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=""1"" class=""dataframe"">\n  <thead>\n    <tr style=""text-align: right;"">\n      <th></th>\n      <th>Unnamed: 0</th>\n      <th>mean radius</th>\n      <th>mean texture</th>\n      <th>mean perimeter</th>\n      <th>mean area</th>\n      <th>mean smoothness</th>\n      <th>mean compactness</th>\n      <th>mean concavity</th>\n      <th>mean concave points</th>\n      <th>mean symmetry</th>\n      <th>...</th>\n      <th>worst texture</th>\n      <th>worst perimeter</th>\n      <th>worst area</th>\n      <th>worst smoothness</th>\n      <th>worst compactness</th>\n      <th>worst concavity</th>\n      <th>worst concave points</th>\n      <th>worst symmetry</th>\n      <th>worst fractal dimension</th>\n      <th>breast_cancer_yn</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>68</th>\n      <td>68</td>\n      <td>0.065527</td>\n      <td>17.33</td>\n      <td>58.79</td>\n      <td>-1.139118</td>\n      <td>0.10660</td>\n      <td>0.14130</td>\n      <td>0.31300</td>\n      <td>0.04375</td>\n      <td>0.2111</td>\n      <td>...</td>\n      <td>22.65</td>\n      <td>65.50</td>\n      <td>324.7</td>\n      <td>0.14820</td>\n      <td>0.43650</td>\n      <td>1.25200</td>\n      <td>0.17500</td>\n      <td>0.4228</td>\n      <td>0.11750</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>181</th>\n      <td>181</td>\n      <td>0.656203</td>\n      <td>26.57</td>\n      <td>142.70</td>\n      <td>1.851973</td>\n      <td>0.11410</td>\n      <td>0.28320</td>\n      <td>0.24870</td>\n      <td>0.14960</td>\n      <td>0.2395</td>\n      <td>...</td>\n      <td>33.48</td>\n      <td>176.50</td>\n      <td>2089.0</td>\n      <td>0.14910</td>\n      <td>0.75840</td>\n      <td>0.67800</td>\n      <td>0.29030</td>\n      <td>0.4098</td>\n      <td>0.12840</td>\n      <td>0</td>\n    </tr>\n    <tr>\n      <th>63</th>\n      <td>63</td>\n      <td>0.072579</td>\n      <td>13.86</td>\n      <td>59.20</td>\n      <td>-1.109785</td>\n      <td>0.07721</td>\n      <td>0.08751</td>\n      <td>0.05988</td>\n      <td>0.02180</td>\n      <td>0.2341</td>\n      <td>...</td>\n      <td>19.23</td>\n      <td>65.59</td>\n      <td>310.1</td>\n      <td>0.09836</td>\n      <td>0.16780</td>\n      <td>0.13970</td>\n      <td>0.05087</td>\n      <td>0.3282</td>\n      <td>0.08490</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>248</th>\n      <td>248</td>\n      <td>0.144914</td>\n      <td>25.22</td>\n      <td>68.01</td>\n      <td>-0.866944</td>\n      <td>0.09657</td>\n      <td>0.07234</td>\n      <td>0.02379</td>\n      <td>0.01615</td>\n      <td>0.1897</td>\n      <td>...</td>\n      <td>35.19</td>\n      <td>77.98</td>\n      <td>455.7</td>\n      <td>0.14990</td>\n      <td>0.13980</td>\n      <td>0.11250</td>\n      <td>0.06136</td>\n      <td>0.3409</td>\n      <td>0.08147</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>60</th>\n      <td>60</td>\n      <td>0.121407</td>\n      <td>14.88</td>\n      <td>64.55</td>\n      <td>-0.965942</td>\n      <td>0.11340</td>\n      <td>0.08061</td>\n      <td>0.01084</td>\n      <td>0.01290</td>\n      <td>0.2743</td>\n      <td>...</td>\n      <td>17.45</td>\n      <td>69.86</td>\n      <td>368.6</td>\n      <td>0.12750</td>\n      <td>0.09866</td>\n      <td>0.02168</td>\n      <td>0.02579</td>\n      <td>0.3557</td>\n      <td>0.08020</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n<p>5 rows  32 columns</p>\n</div>'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Displayed on the user's machine.""}, {'role': 'assistant', 'type': 'message', 'content': 'The `mean area` has been successfully standard scaled. Next, I will perform linear regression to regress the breast cancer indicator on the scaled mean area and report the coefficient.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Initialize and fit the linear regression model for mean area\nX_train_area = train_data_scaled[['mean area']]\ny_train_area = train_data_scaled['breast_cancer_yn']\n\nmodel_area = LinearRegression()\nmodel_area.fit(X_train_area, y_train_area)\n\n# Get the coefficient for mean area\nmean_area_coefficient = model_area.coef_[0]\nround(mean_area_coefficient, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(-0.336)'}, {'role': 'assistant', 'type': 'message', 'content': 'The coefficient for the standardized mean area in the linear regression model is -0.336. If you need more information or have additional questions, feel free to ask!'}]"
38,"[{'role': 'assistant', 'type': 'message', 'content': ""To find the absolute difference in the mean area between individuals with and without breast cancer, I will calculate the mean area for each group and then find the absolute difference. Let's perform this calculation.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the mean area for each group\ngroup_with_cancer_area_mean = data_no_missing[data_no_missing['breast_cancer_yn'] == 1]['mean area'].mean()\ngroup_without_cancer_area_mean = data_no_missing[data_no_missing['breast_cancer_yn'] == 0]['mean area'].mean()\n\n# Calculate the absolute difference\nabsolute_difference = abs(group_with_cancer_area_mean - group_without_cancer_area_mean)\nround(absolute_difference, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(515.586)'}, {'role': 'assistant', 'type': 'message', 'content': ""The absolute difference in the mean area between those with breast cancer and those without is 515.586. If there's anything else you'd like to explore, just let me know!""}]"
39,"[{'role': 'assistant', 'type': 'message', 'content': ""To find the fifth largest mean radius value in the dataset, I'll sort the `mean radius` values in descending order and identify the fifth largest. Let's proceed with that calculation.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Sort the mean radius values in descending order and find the fifth largest\nfifth_largest_mean_radius = data_no_missing['mean radius'].nlargest(5).iloc[-1]\nround(fifth_largest_mean_radius, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(25.22)'}, {'role': 'assistant', 'type': 'message', 'content': 'The fifth largest mean radius value in the dataset is 25.220. If you have any more questions or need further assistance, feel free to ask!'}]"
40,"[{'role': 'assistant', 'type': 'message', 'content': 'To compute the interquartile range (IQR) of the ""mean radius"", I\'ll determine the 25th and 75th percentiles, subtract them to find the IQR, and then use 1.5 times the IQR to identify outliers. Let\'s perform these calculations.'}]"
41,"[{'role': 'assistant', 'type': 'message', 'content': ""To find the average income, I'll calculate the mean of the `income` column from the entire dataset, temporarily dropping any rows with missing values in this column before the calculation. Let's proceed with this analysis.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average income, dropping rows with missing values in the 'income' column\naverage_income = dataset['income'].dropna().mean()\n\naverage_income_rounded = round(average_income, 3)\naverage_income_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n   3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n   3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'income'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[408], line 4\n      2 pass\n      3 print('##active_line2##')\n----> 4 average_income = dataset['income'].dropna().mean()\n      5 print('##active_line3##')\n      6 pass\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/frame.py:4102, in DataFrame.__getitem__(self, key)\n   4100 if self.columns.nlevels > 1:\n   4101     return self._getitem_multilevel(key)\n-> 4102 indexer = self.columns.get_loc(key)\n   4103 if is_integer(indexer):\n   4104     indexer = [indexer]\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3807     if isinstance(casted_key, slice) or (\n   3808         isinstance(casted_key, abc.Iterable)\n   3809         and any(isinstance(x, slice) for x in casted_key)\n   3810     ):\n   3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n   3813 except TypeError:\n   3814     # If we have a listlike key, _check_indexing_error will raise\n   3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3816     #  the TypeError.\n   3817     self._check_indexing_error(key)\n\nKeyError: 'income'""}, {'role': 'assistant', 'type': 'message', 'content': ""It seems there isn't a column named `income` in the dataset. Let's take a look at the column names to identify the correct column for the income value.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': '# Display the column names\ncolumn_names = dataset.columns\ncolumn_names'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Index(['Unnamed: 0', 'Income', 'Limit', 'Rating', 'Cards', 'Age', 'Education',\n       'Gender', 'Student', 'Married', 'Ethnicity', 'Balance'],\n      dtype='object')""}, {'role': 'assistant', 'type': 'message', 'content': ""The correct column name for income seems to be `Income`. Let's calculate the average income using the correct column name.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average income from the 'Income' column\ngood_income = dataset['Income'].dropna().mean()\n\n# Round the result\ngood_income_rounded = round(good_income, 3)\ngood_income_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(45.219)'}, {'role': 'assistant', 'type': 'message', 'content': 'The average income in the dataset is approximately $45.219. If you have any more questions or need further analysis, feel free to ask!'}]"
42,"[{'role': 'assistant', 'type': 'message', 'content': ""To determine how many individuals in the dataset are married, I'll count the number of occurrences for the `Married` column, temporarily dropping any rows with missing values in this column. Let's find that out.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Count the number of married individuals\nmarried_count = dataset['Married'].dropna().value_counts().get('Yes', 0)\nmarried_count""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.int64(245)'}, {'role': 'assistant', 'type': 'message', 'content': 'There are 245 individuals in the dataset who are married. If you need further analysis or have any other questions, let me know!'}]"
43,"[{'role': 'assistant', 'type': 'message', 'content': ""To find the average number of credit cards, I'll calculate the mean of the `Cards` column from the dataset, temporarily dropping any rows with missing values in this column before the calculation. Let's do this now.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average number of cards\naverage_cards = dataset['Cards'].dropna().mean()\n\n# Round the result\naverage_cards_rounded = round(average_cards, 3)\naverage_cards_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(2.958)'}, {'role': 'assistant', 'type': 'message', 'content': 'The average number of credit cards in the dataset is approximately 2.958. If you have any more queries or need additional analysis, feel free to ask!'}]"
44,"[{'role': 'assistant', 'type': 'message', 'content': ""To address this, we will first identify the five highest and lowest earners using the `Income` column. Then, we'll calculate the average ratings for each group and find the difference between these two averages.\n\nLet's proceed with this analysis.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Sort the dataset by 'Income' and drop rows with missing values in 'Income' or 'Rating'\nsorted_data = dataset.dropna(subset=['Income', 'Rating']).sort_values(by='Income')\n\n# Extract the five lowest and five highest earners\nlowest_earners = sorted_data.head(5)\nhighest_earners = sorted_data.tail(5)\n\n# Calculate the average ratings for the two groups\navg_rating_lowest = lowest_earners['Rating'].mean()\navg_rating_highest = highest_earners['Rating'].mean()\n\n# Calculate the difference between the two averages\ndifference_rating = avg_rating_highest - avg_rating_lowest\n\n# Round the difference\nround(difference_rating, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(550.8)'}, {'role': 'assistant', 'type': 'message', 'content': 'The difference between the average ratings of the five highest earners and the five lowest earners is approximately 550.8. If you have any further questions or need more analysis, feel free to ask!'}]"
45,"[{'role': 'assistant', 'type': 'message', 'content': ""To determine the number of unique ethnicities in the dataset, I'll examine the `Ethnicity` column for distinct values, temporarily dropping any rows with missing values in this column. Let's find that out.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Find the number of unique ethnicities, dropping rows with missing values in the 'Ethnicity' column\nunique_ethnicities = dataset['Ethnicity'].dropna().nunique()\nunique_ethnicities""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '3'}, {'role': 'assistant', 'type': 'message', 'content': 'There are 3 unique ethnicities in the dataset. If you have any more questions or need further analysis, feel free to ask!'}]"
46,"[{'role': 'assistant', 'type': 'message', 'content': 'To create the new `income_categories` variable, I\'ll classify the `Income` values into ""low"", ""medium"", and ""high"" categories based on the specified criteria. Then, I\'ll count the number of high income earners.\n\nLet\'s perform these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Define the income categories based on the given thresholds\ndef categorize_income(income):\n    if income < 40:\n        return 'low'\n    elif income < 80:\n        return 'medium'\n    else:\n        return 'high'\n\n# Apply the categorization to the entire dataset\n\ndataset['income_categories'] = dataset['Income'].apply(categorize_income)\n\n# Count the number of high income earners\nhigh_income_count = dataset['income_categories'].value_counts().get('high', 0)\n\nhigh_income_count""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.int64(55)'}, {'role': 'assistant', 'type': 'message', 'content': 'There are 55 high income earners in the dataset. If you need more assistance or have other questions, feel free to let me know!'}]"
47,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if the average number of credit cards differs significantly between the `income_categories`, we can perform an ANOVA (Analysis of Variance) test. This will tell us if there are statistically significant differences in the average number of cards across the different income categories (""low"", ""medium"", ""high"").\n\nLet\'s perform the ANOVA test.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import f_oneway\n\n# Prepare data for ANOVA test, dropping missing values in 'Cards'\nincome_categories_data = dataset.dropna(subset=['Cards', 'income_categories'])\n\n# Split the data into groups based on income categories\nlow_group = income_categories_data[income_categories_data['income_categories'] == 'low']['Cards']\nmedium_group = income_categories_data[income_categories_data['income_categories'] == 'medium']['Cards']\nhigh_group = income_categories_data[income_categories_data['income_categories'] == 'high']['Cards']\n\n# Perform ANOVA test\nanova_result = f_oneway(low_group, medium_group, high_group)\np_value = anova_result.pvalue\n\np_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.8601319002443438)'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value from the ANOVA test is approximately 0.860. Since this value is greater than the significance level of 0.05, we fail to reject the null hypothesis and conclude that there is no statistically significant difference in the average number of cards among the different income categories.\n\nIf you have more questions or need further analysis, let me know!'}]"
48,"[{'role': 'assistant', 'type': 'message', 'content': 'To perform a linear regression of ""Limit"" on ""income_categories"", we\'ll first convert the categorical `income_categories` into numerical format using one-hot encoding. We\'ll then fit a linear regression model on the train set and evaluate its \\( R^2 \\) score on the test set.\n\nLet\'s go through these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import r2_score\nfrom sklearn.preprocessing import OneHotEncoder\n\n# Convert income_categories to one-hot encoding\nencoder = OneHotEncoder(drop='first', sparse=False)\n\n# Fit and transform the train data attributes\nX_train_encoded = encoder.fit_transform(train_data[['income_categories']])\nX_test_encoded = encoder.transform(test_data[['income_categories']])\n\n# Extract the target variable\nY_train = train_data['Limit']\nY_test = test_data['Limit']\n\n# Initialize and train the linear regression model\nmodel = LinearRegression()\nmodel.fit(X_train_encoded, Y_train)\n\n# Predict the test set and calculate R-squared\nY_pred = model.predict(X_test_encoded)\n\ntest_r_squared = r2_score(Y_test, Y_pred)\n\ntest_r_squared""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[417], line 12\n     10 pass\n     11 print('##active_line6##')\n---> 12 encoder = OneHotEncoder(drop='first', sparse=False)\n     13 print('##active_line7##')\n     14 pass\n\nTypeError: OneHotEncoder.__init__() got an unexpected keyword argument 'sparse'""}, {'role': 'assistant', 'type': 'message', 'content': ""It seems there was an issue with the `OneHotEncoder` initialization due to the incorrect argument name. The correct argument should be `sparse_output=False` for the latest versions of scikit-learn. Let's fix that and rerun the regression.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Use the correct argument name for OneHotEncoder initialization\nencoder = OneHotEncoder(drop='first', sparse_output=False)\n\n# Fit and transform the train data attributes\nX_train_encoded = encoder.fit_transform(train_data[['income_categories']])\nX_test_encoded = encoder.transform(test_data[['income_categories']])\n\n# Extract the target variable\nY_train = train_data['Limit']\nY_test = test_data['Limit']\n\n# Initialize and train the linear regression model\nmodel = LinearRegression()\nmodel.fit(X_train_encoded, Y_train)\n\n# Predict the test set and calculate R-squared\nY_pred = model.predict(X_test_encoded)\n\ntest_r_squared = r2_score(Y_test, Y_pred)\n\ntest_r_squared""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[418], line 10\n      8 pass\n      9 print(\'##active_line5##\')\n---> 10 X_train_encoded = encoder.fit_transform(train_data[[\'income_categories\']])\n     11 print(\'##active_line6##\')\n     12 X_test_encoded = encoder.transform(test_data[[\'income_categories\']])\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/frame.py:4108, in DataFrame.__getitem__(self, key)\n   4106     if is_iterator(key):\n   4107         key = list(key)\n-> 4108     indexer = self.columns._get_indexer_strict(key, ""columns"")[1]\n   4110 # take() does not accept boolean indexers\n   4111 if getattr(indexer, ""dtype"", None) == bool:\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:6200, in Index._get_indexer_strict(self, key, axis_name)\n   6197 else:\n   6198     keyarr, indexer, new_indexer = self._reindex_non_unique(keyarr)\n-> 6200 self._raise_if_missing(keyarr, indexer, axis_name)\n   6202 keyarr = self.take(indexer)\n   6203 if isinstance(key, Index):\n   6204     # GH 42790 - Preserve name from an Index\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:6249, in Index._raise_if_missing(self, key, indexer, axis_name)\n   6247 if nmissing:\n   6248     if nmissing == len(indexer):\n-> 6249         raise KeyError(f""None of [{key}] are in the [{axis_name}]"")\n   6251     not_found = list(ensure_index(key)[missing_mask.nonzero()[0]].unique())\n   6252     raise KeyError(f""{not_found} not in index"")\n\nKeyError: ""None of [Index([\'income_categories\'], dtype=\'object\')] are in the [columns]""'}, {'role': 'assistant', 'type': 'message', 'content': ""It looks like the `income_categories` column is not present in the train and test datasets. I need to ensure this column is added to both datasets before proceeding with the regression. Let's add the `income_categories` column to the train and test datasets, then retry the regression.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Adding the 'income_categories' column to the train and test datasets based on the income ranges\ndef categorize_income_updated(income):\n    if income < 40:\n        return 'low'\n    elif income < 80:\n        return 'medium'\n    else:\n        return 'high'\n\n# Apply the categorization to train and test datasets\ntrain_data['income_categories'] = train_data['Income'].apply(categorize_income_updated)\ntest_data['income_categories'] = test_data['Income'].apply(categorize_income_updated)\n\n# Retry linear regression\nencoder = OneHotEncoder(drop='first', sparse_output=False)\n\n# Fit and transform the train data attributes\nX_train_encoded = encoder.fit_transform(train_data[['income_categories']])\nX_test_encoded = encoder.transform(test_data[['income_categories']])\n\n# Extract the target variable\nY_train = train_data['Limit']\nY_test = test_data['Limit']\n\n# Initialize and train the linear regression model\nmodel = LinearRegression()\nmodel.fit(X_train_encoded, Y_train)\n\n# Predict the test set and calculate R-squared\nY_pred = model.predict(X_test_encoded)\n\ntest_r_squared = r2_score(Y_test, Y_pred)\n\ntest_r_squared""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '0.41792794696223345'}, {'role': 'assistant', 'type': 'message', 'content': 'The test R-squared value for the linear regression of ""Limit"" on ""income_categories"" is approximately 0.418. If you have further questions or need additional analysis, feel free to ask!'}]"
49,"[{'role': 'assistant', 'type': 'message', 'content': ""To include both `income_categories` and `Age` in the linear regression model, I'll first ensure that `income_categories` is transformed into a format suitable for regression using one-hot encoding. Then I'll fit a linear regression model and determine the coefficient for `Age`.\n\nLet's proceed with these steps.""}]"
50,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if there\'s a statistically significant difference in the means of ""Limit"" between the ""Student"" levels (""Yes"" or ""No""), we can perform a t-test. First, we will drop missing values in the relevant columns and then conduct the t-test.\n\nLet\'s perform this analysis.'}]"
51,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine the different classes of ""Sex"" in the dataset, we\'ll examine the unique values in the ""Sex"" column. Let\'s retrieve and count these unique values.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Get the unique classes for 'Sex' column\ndifferent_classes_sex = data['Sex'].unique()\nnumber_of_classes = len(different_classes_sex)\n(different_classes_sex, number_of_classes)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""(array(['M', 'F', 'I'], dtype=object), 3)""}, {'role': 'assistant', 'type': 'message', 'content': 'There are **3 different classes** of ""Sex"" in the dataset: \'M\' (Male), \'F\' (Female), and \'I\' (Infant).'}]"
52,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the mean diameter, we\'ll calculate the average of the ""Diameter"" column in the dataset. Let\'s perform this calculation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the mean of the 'Diameter' column\nmean_diameter = data['Diameter'].mean()\nround(mean_diameter, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.408)'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean diameter of the dataset is approximately **0.408**.'}]"
53,"[{'role': 'assistant', 'type': 'message', 'content': 'To compute the variance of the ""Shucked weight"" column, let\'s calculate it using the entire dataset.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the variance of the 'Shucked weight' column\nvariance_shucked_weight = data['Shucked weight'].var()\nround(variance_shucked_weight, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.049)'}, {'role': 'assistant', 'type': 'message', 'content': 'The variance of the shucked weight is approximately **0.049**.'}]"
54,"[{'role': 'assistant', 'type': 'message', 'content': 'To calculate the average diameter for individuals with ""Sex"" set to ""M"" (Male), we will filter the dataset based on this condition and then compute the mean of the ""Diameter"" column. Let\'s do this calculation.'}]"
55,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the correlation between ""Diameter"" and ""Rings"", we\'ll use Pearson\'s correlation coefficient, which will also provide us the p-value. This will help us determine if there is a significant linear relationship between the two variables.\n\nLet\'s calculate the correlation and the p-value.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import pearsonr\n\n# Calculate Pearson's correlation coefficient and the p-value\ncorrelation, p_value = pearsonr(data['Diameter'].dropna(), data['Rings'].dropna())\n(round(correlation, 3), round(p_value, 3))""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.575), np.float64(0.0))'}, {'role': 'assistant', 'type': 'message', 'content': 'The correlation between diameter and rings is approximately **0.575**, with a p-value of **0.0**. This indicates a moderate positive correlation, and the relationship is statistically significant at the 0.05 significance level.'}]"
56,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if the ""Diameter"" is normally distributed, we can perform a statistical test such as the Shapiro-Wilk test. This test will provide us with a p-value to help decide if the diameter data significantly deviates from a normal distribution.\n\nLet\'s perform the Shapiro-Wilk test on the ""Diameter"" column.'}]"
57,"[{'role': 'assistant', 'type': 'message', 'content': 'To assess if there\'s a statistically significant difference in the average ""Diameter"" between the ""Sex"" categories, we can use a one-way ANOVA test. This test is suitable for comparing means across multiple groups.\n\nLet\'s perform the ANOVA test on the ""Diameter"" column grouped by ""Sex"".'}]"
58,"[{'role': 'assistant', 'type': 'message', 'content': 'To create a new variable called ""Area"" by multiplying the ""Length"" and ""Height"" columns, and then report the median of this new variable, we\'ll perform the following steps:\n\n1. Compute the ""Area"" as the product of ""Length"" and ""Height"".\n2. Calculate and report the median of ""Area"".\n\nLet\'s proceed with these calculations.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create new variable 'Area' as the product of 'Length' and 'Height'\ndata['Area'] = data['Length'] * data['Height']\n\n# Calculate the median of the 'Area'\nmedian_area = data['Area'].median()\nround(median_area, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.078)'}, {'role': 'assistant', 'type': 'message', 'content': 'The median of the newly created ""Area"" variable is approximately **0.078**.'}]"
59,"[{'role': 'assistant', 'type': 'message', 'content': 'To create the ""LargeArea"" variable, we\'ll categorize each entry as ""Yes"" if the ""Area"" is at least 0.0775, and ""No"" otherwise. Then we\'ll count how many entries fall into the ""Yes"" category. Let\'s perform these operations.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create the 'LargeArea' variable based on the condition given\ndata['LargeArea'] = data['Area'].apply(lambda x: 'Yes' if x >= 0.0775 else 'No')\n\n# Count the number of entries with 'Yes' for 'LargeArea'\nlarge_area_yes_count = data[data['LargeArea'] == 'Yes'].shape[0]\nlarge_area_yes_count""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '2089'}, {'role': 'assistant', 'type': 'message', 'content': 'There are **2,089** examples in the dataset with ""Yes"" for the ""LargeArea"" category.'}]"
60,"[{'role': 'assistant', 'type': 'message', 'content': 'To fit a linear regression model to predict ""Shucked weight"" using ""LargeArea"" and ""Area"", and report the test mean absolute error (MAE), we\'ll follow these steps:\n\n1. Encode the ""LargeArea"" categorical variable into numerical format.\n2. Use the train dataset to fit the linear regression model.\n3. Predict the ""Shucked weight"" on the test dataset.\n4. Calculate the mean absolute error on the test predictions.\n\nLet\'s implement these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_absolute_error\nfrom sklearn.preprocessing import LabelEncoder\n\n# Step 1: Encode 'LargeArea' into numerical format in both train and test sets\nle = LabelEncoder()\ntrain_data['LargeArea_encoded'] = le.fit_transform(train_data['LargeArea'])\ntest_data['LargeArea_encoded'] = le.transform(test_data['LargeArea'])\n\n# Step 2: Fit the linear regression model using 'LargeArea_encoded' and 'Area'\nX_train = train_data[['LargeArea_encoded', 'Area']]\ny_train = train_data['Shucked weight']\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Step 3: Predict 'Shucked weight' for the test dataset\nX_test = test_data[['LargeArea_encoded', 'Area']]\ny_test = test_data['Shucked weight']\ny_pred = model.predict(X_test)\n\n# Step 4: Calculate and report the mean absolute error\nmae = mean_absolute_error(y_test, y_pred)\nround(mae, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n   3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n   3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'LargeArea'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[428], line 14\n     12 le = LabelEncoder()\n     13 print('##active_line7##')\n---> 14 train_data['LargeArea_encoded'] = le.fit_transform(train_data['LargeArea'])\n     15 print('##active_line8##')\n     16 test_data['LargeArea_encoded'] = le.transform(test_data['LargeArea'])\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/frame.py:4102, in DataFrame.__getitem__(self, key)\n   4100 if self.columns.nlevels > 1:\n   4101     return self._getitem_multilevel(key)\n-> 4102 indexer = self.columns.get_loc(key)\n   4103 if is_integer(indexer):\n   4104     indexer = [indexer]\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3807     if isinstance(casted_key, slice) or (\n   3808         isinstance(casted_key, abc.Iterable)\n   3809         and any(isinstance(x, slice) for x in casted_key)\n   3810     ):\n   3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n   3813 except TypeError:\n   3814     # If we have a listlike key, _check_indexing_error will raise\n   3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3816     #  the TypeError.\n   3817     self._check_indexing_error(key)\n\nKeyError: 'LargeArea'""}, {'role': 'assistant', 'type': 'message', 'content': 'It seems that the ""LargeArea"" variable was not carried over to the train and test datasets after the initial split. To remedy this, let\'s create the ""Area"" and ""LargeArea"" variables again and ensure they\'re included in both datasets. Then, we\'ll fit the regression model.\n\nLet me address this step-by-step.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Recreate 'Area' and 'LargeArea' variables in both datasets\ntrain_data['Area'] = train_data['Length'] * train_data['Height']\ntest_data['Area'] = test_data['Length'] * test_data['Height']\n\ntrain_data['LargeArea'] = train_data['Area'].apply(lambda x: 'Yes' if x >= 0.0775 else 'No')\ntest_data['LargeArea'] = test_data['Area'].apply(lambda x: 'Yes' if x >= 0.0775 else 'No')\n\n# Encode 'LargeArea' into numerical format\nle = LabelEncoder()\ntrain_data['LargeArea_encoded'] = le.fit_transform(train_data['LargeArea'])\ntest_data['LargeArea_encoded'] = le.transform(test_data['LargeArea'])\n\n# Fit the linear regression model using 'LargeArea_encoded' and 'Area'\nX_train = train_data[['LargeArea_encoded', 'Area']]\ny_train = train_data['Shucked weight']\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Predict 'Shucked weight' for the test dataset\nX_test = test_data[['LargeArea_encoded', 'Area']]\ny_test = test_data['Shucked weight']\ny_pred = model.predict(X_test)\n\n# Calculate and report the mean absolute error\nmae = mean_absolute_error(y_test, y_pred)\nround(mae, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '0.066'}, {'role': 'assistant', 'type': 'message', 'content': 'The test mean absolute error for the linear regression model predicting ""Shucked weight"" using ""LargeArea"" and ""Area"" is approximately **0.066**.'}]"
61,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if ""LargeArea"" and ""Sex"" are statistically independent, we can use the Chi-square test of independence. This test will help us assess whether there is a significant association between the two categorical variables.\n\nLet\'s perform the Chi-square test on these variables.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import chi2_contingency\n\n# Create a contingency table of 'LargeArea' and 'Sex'\ncontingency_table = pd.crosstab(data['LargeArea'], data['Sex'])\n\n# Perform the Chi-square test of independence\nchi2, p_value, _, _ = chi2_contingency(contingency_table)\nround(p_value, 3)""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.0)'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value from the Chi-square test of independence between ""LargeArea"" and ""Sex"" is approximately **0.0**. This suggests that there is a statistically significant association between these two variables, meaning they are not independent at the 0.05 significance level.'}]"
62,"[{'role': 'assistant', 'type': 'message', 'content': 'Let\'s calculate the mean and standard deviation of the batting average using the entire dataset, considering the rules you provided. If ""batting average"" is not a specific column, please let me know the exact name or provide additional guidance. For now, I\'ll assume there is a column named ""BattingAverage"" or similar. Let\'s proceed.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': '# Check for the column names to identify the batting average column\ndata.columns'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Index(['salary_in_thousands_of_dollars', 'batting_average',\n       'on_base_percentage', 'number_of_runs', 'number_of_hits',\n       'number_of_doubles', 'number_of_triples', 'number_of_home_runs',\n       'number_of_runs_batted_in', 'number_of_walks', 'number_of_strike_outs',\n       'number_of_stolen_bases', 'number_of_errors',\n       'indicator_of_free_agency_eligibility',\n       'indicator_of_free_agent_in_1991_1992',\n       'indicator_of_arbitration_eligibility',\n       'indicator_of_arbitration_in_1991_1992'],\n      dtype='object')""}, {'role': 'assistant', 'type': 'message', 'content': ""The column representing the batting average is named `batting_average`. I'll calculate the mean and standard deviation for this column, considering the entire dataset.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Drop rows with missing values in batting_average column\nbatting_data = data['batting_average'].dropna()\n\n# Calculate mean and standard deviation\nmean_batting_average = batting_data.mean()\nstd_batting_average = batting_data.std()\n\nmean_batting_average, std_batting_average""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.2576904761904762), np.float64(0.039528104852185886))'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean batting average is 0.258, and the standard deviation is 0.040. If you have any more queries or need further analysis, feel free to let me know!'}]"
63,"[{'role': 'assistant', 'type': 'message', 'content': ""To assess whether the batting average adheres to a normal distribution, we'll conduct a normality test. The Shapiro-Wilk test is a common choice for this purpose. A p-value less than 0.05 would suggest the data does not follow a normal distribution.\n\nLet's perform the Shapiro-Wilk test on the batting average data.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': 'from scipy.stats import shapiro\n\n# Perform the Shapiro-Wilk test\nstat, p_value = shapiro(batting_data)\n\nstat, p_value'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.9467600655582505), np.float64(1.1919341599316368e-09))'}, {'role': 'assistant', 'type': 'message', 'content': ""The Shapiro-Wilk test statistic is 0.947, with a p-value of approximately \\(1.192 \\times 10^{-9}\\). Since the p-value is less than 0.05, we reject the null hypothesis and conclude that the batting average does not adhere to a normal distribution. If there's anything else you need, please let me know!""}]"
64,"[{'role': 'assistant', 'type': 'message', 'content': ""To determine if there is a significant correlation between batting average and salary, we can use Pearson's correlation coefficient. This test will help us determine both the strength and the significance of the linear relationship between the two variables.\n\nLet's proceed with Pearson's correlation analysis on these variables. I'll conduct the test and provide the results.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Drop rows with missing values in the columns of interest\ncorrelation_data = data[['batting_average', 'salary_in_thousands_of_dollars']].dropna()\n\n# Calculate Pearson's correlation\ncorrelation, p_value = correlation_data.corr().iloc[0, 1], corr_p_value = shapiro(correlation_data['batting_average'])\n\ncorrelation, p_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '/var/folders/fz/1btg0vkx2yl8sf_1hwcxk5dw0000gn/T/ipykernel_18994/4261970227.py:10: FutureWarning: ChainedAssignmentError: behaviour will change in pandas 3.0!\nYou are setting values through chained assignment. Currently this works in certain cases, but when using Copy-on-Write (which will become the default behaviour in pandas 3.0) this will never work to update the original DataFrame or Series, because the intermediate object on which we are setting values will behave as a copy.\nA typical example is when you are setting values in a column of a DataFrame, like:\n\ndf[""col""][row_indexer] = value\n\nUse `df.loc[row_indexer, ""col""] = values` instead, to perform the assignment in a single step and ensure this keeps updating the original `df`.\n\nSee the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy\n\n  correlation, p_value = correlation_data.corr().iloc[0, 1], corr_p_value = shapiro(correlation_data[\'batting_average\'])\n(np.float64(0.9467600655582505), np.float64(1.1919341599316368e-09))'}, {'role': 'assistant', 'type': 'message', 'content': 'I made an error in the calculation process. Let me correct it and provide the accurate correlation and p-value.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import pearsonr\n\n# Calculate Pearson's correlation and its p-value for salary and batting average\ncorrelation, p_value = pearsonr(correlation_data['batting_average'], correlation_data['salary_in_thousands_of_dollars'])\n\ncorrelation, p_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.2792783805274621), np.float64(1.9494863100076396e-07))'}, {'role': 'assistant', 'type': 'message', 'content': 'The Pearson correlation coefficient between batting average and salary is 0.279, with a p-value of approximately \\(1.949 \\times 10^{-7}\\). The positive correlation suggests a mild linear relationship, and since the p-value is less than 0.05, this correlation is statistically significant.'}]"
65,"[{'role': 'assistant', 'type': 'message', 'content': ""To min-max scale the salary, we transform it such that the values range between 0 and 1. This will impact the mean and standard deviation of the salary. I'll perform the scaling on the training data, then apply the transformer to the test data, according to your rules. Let's begin by min-max scaling the salary.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.preprocessing import MinMaxScaler\n\n# Initialize the MinMaxScaler\ndrop_rows_train = train_data.dropna(subset=['salary_in_thousands_of_dollars'])\ndrop_rows_test = test_data.dropna(subset=['salary_in_thousands_of_dollars'])\nscaler = MinMaxScaler()\n\n# Fit the scaler on the training data & transform both\ntrain_data['salary_scaled'] = scaler.fit_transform(drop_rows_train[['salary_in_thousands_of_dollars']])\ntest_data['salary_scaled'] = scaler.transform(drop_rows_test[['salary_in_thousands_of_dollars']])\n\n# Calculate new mean and standard deviation for the scaled salary\nnew_mean_salary = train_data['salary_scaled'].mean()\nnew_std_salary = train_data['salary_scaled'].std()\n\nnew_mean_salary, new_std_salary""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.19319065339024646), np.float64(0.20891813641984555))'}, {'role': 'assistant', 'type': 'message', 'content': 'After min-max scaling the salary, the new mean is 0.193, and the new standard deviation is 0.209. If you need further assistance or have more questions, feel free to ask!'}]"
66,"[{'role': 'assistant', 'type': 'message', 'content': ""To regress the salary on batting average using linear regression, we'll fit the model on the training data and evaluate it on the test data. The root mean square error (RMSE) will be calculated on the test set to assess the model's performance.\n\nLet's proceed with this analysis.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\nimport numpy as np\n\n# Prepare training and testing data\nX_train = drop_rows_train[['batting_average']].fillna(train_data['batting_average'].mean())\ny_train = drop_rows_train['salary_scaled']\nX_test = drop_rows_test[['batting_average']].fillna(test_data['batting_average'].mean())\ny_test = drop_rows_test['salary_scaled']\n\n# Initialize and fit the Linear Regression model\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Predict on the test set\ny_pred = model.predict(X_test)\n\n# Calculate RMSE\nrmse = np.sqrt(mean_squared_error(y_test, y_pred))\n\nrmse""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n   3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n   3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'salary_scaled'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[438], line 14\n     12 X_train = drop_rows_train[['batting_average']].fillna(train_data['batting_average'].mean())\n     13 print('##active_line7##')\n---> 14 y_train = drop_rows_train['salary_scaled']\n     15 print('##active_line8##')\n     16 X_test = drop_rows_test[['batting_average']].fillna(test_data['batting_average'].mean())\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/frame.py:4102, in DataFrame.__getitem__(self, key)\n   4100 if self.columns.nlevels > 1:\n   4101     return self._getitem_multilevel(key)\n-> 4102 indexer = self.columns.get_loc(key)\n   4103 if is_integer(indexer):\n   4104     indexer = [indexer]\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3807     if isinstance(casted_key, slice) or (\n   3808         isinstance(casted_key, abc.Iterable)\n   3809         and any(isinstance(x, slice) for x in casted_key)\n   3810     ):\n   3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n   3813 except TypeError:\n   3814     # If we have a listlike key, _check_indexing_error will raise\n   3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3816     #  the TypeError.\n   3817     self._check_indexing_error(key)\n\nKeyError: 'salary_scaled'""}, {'role': 'assistant', 'type': 'message', 'content': ""It seems there was an error because the scaled salary column wasn't correctly applied in the training and test sets. Let me fix this and perform the linear regression analysis again. I'll ensure the data alignment is correct this time.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Fit the MinMaxScaler on the salary data (after dropping NaN rows) and apply the transformation\nscaler = MinMaxScaler()\ntrain_data['salary_scaled'] = scaler.fit_transform(train_data[['salary_in_thousands_of_dollars']])\ntest_data['salary_scaled'] = scaler.transform(test_data[['salary_in_thousands_of_dollars']])\n\n# Remove entries from both train and test datasets which are missing values for salary or batting average\ntrain_filtered = train_data.dropna(subset=['batting_average', 'salary_scaled'])\ntest_filtered = test_data.dropna(subset=['batting_average', 'salary_scaled'])\n\n# Redefine X and y for regression analysis\nX_train = train_filtered[['batting_average']]\ny_train = train_filtered['salary_scaled']\nX_test = test_filtered[['batting_average']]\ny_test = test_filtered['salary_scaled']\n\n# Initialize, fit, predict using Linear Regression\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Make predictions on the test set\ny_pred = model.predict(X_test)\n\n# Calculate RMSE for predictions\nrmse = np.sqrt(mean_squared_error(y_test, y_pred))\n\nrmse""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.19040422500403187)'}, {'role': 'assistant', 'type': 'message', 'content': 'The test RMSE (Root Mean Square Error) of the linear regression model, predicting salary from the batting average, is 0.190. If you have more analyses to conduct or questions to ask, feel free to let me know!'}]"
67,"[{'role': 'assistant', 'type': 'message', 'content': ""To find outliers based on the interquartile range (IQR) method, we need to:\n\n1. Calculate the IQR of the batting average.\n2. Determine the boundaries for outliers using 1.5 times the IQR below the first quartile (Q1) and above the third quartile (Q3).\n3. Count the number of outliers outside these limits.\n\nLet's execute these steps.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': '# Calculate Q1 (25th percentile) and Q3 (75th percentile)\nQ1 = batting_data.quantile(0.25)\nQ3 = batting_data.quantile(0.75)\n\n# Compute IQR\nIQR = Q3 - Q1\n\n# Define outlier boundaries\nlower_bound = Q1 - 1.5 * IQR\nupper_bound = Q3 + 1.5 * IQR\n\n# Identify outliers\noutliers = batting_data[(batting_data < lower_bound) | (batting_data > upper_bound)]\n\n# Count the number of outliers\nnum_outliers = len(outliers)\n\nlower_bound, upper_bound, num_outliers'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.17349999999999993), np.float64(0.3455000000000001), 10)'}, {'role': 'assistant', 'type': 'message', 'content': 'The interquartile range (IQR) method identifies outliers in the batting average using these boundaries:\n\n- Lower Bound: 0.173\n- Upper Bound: 0.346\n\nThere are 10 outliers in the dataset when using 1.5 times the IQR to determine them. If you need further analysis or information, please let me know!'}]"
68,"[{'role': 'assistant', 'type': 'message', 'content': ""Let's create a new variable called `hits_and_runs` by summing the `number_of_runs` and `number_of_hits` columns. Then, we'll calculate the mean and kurtosis of this new variable for the entire dataset. ""}]"
69,"[{'role': 'assistant', 'type': 'message', 'content': ""Let's first standardize the `hits_and_runs` variable by subtracting the mean and dividing by the standard deviation. After that, we'll calculate its median.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import zscore\n\n# Create the new variable 'hits_and_runs'\ndata['hits_and_runs'] = data['number_of_runs'] + data['number_of_hits']\n\n# Standard scale the 'hits_and_runs' variable\nhits_and_runs_scaled = zscore(data['hits_and_runs'].dropna())\n\n# Calculate the median of the standardized variable\nmedian_scaled_hits_and_runs = pd.Series(hits_and_runs_scaled).median()\n\nmedian_scaled_hits_and_runs""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(-0.1201068131014287)'}, {'role': 'assistant', 'type': 'message', 'content': 'The median of the standardized `hits_and_runs` variable is approximately -0.120. If you have any further questions or need additional analysis, feel free to let me know!'}]"
70,"[{'role': 'assistant', 'type': 'message', 'content': ""To identify which of these variables is most highly correlated with `salary_in_thousands_of_dollars`, I'll calculate the Pearson correlation coefficients between each of the specified variables and the salary. Then I'll compare these to determine which has the highest correlation. Let's proceed with the calculations.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Select relevant columns and drop rows with missing values\nselected_columns = ['batting_average', 'on_base_percentage', 'number_of_runs', 'number_of_hits', 'salary_in_thousands_of_dollars']\ncorrelation_data = data[selected_columns].dropna()\n\n# Calculate Pearson correlations\ncorrelations = {}\nfor col in selected_columns[:-1]:  # Exclude the salary itself\n    corr, _ = pearsonr(correlation_data[col], correlation_data['salary_in_thousands_of_dollars'])\n    correlations[col] = corr\n\n# Identify the variable with the highest correlation\nmax_correlated_variable = max(correlations, key=correlations.get)\nmax_correlation_value = correlations[max_correlated_variable]\n\nmax_correlated_variable, max_correlation_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""('number_of_runs', np.float64(0.6423507251889436))""}, {'role': 'assistant', 'type': 'message', 'content': 'Among the variables considered, `number_of_runs` is most highly correlated with `salary_in_thousands_of_dollars`, with a Pearson correlation coefficient of 0.642. If you need more insights or have any other questions, feel free to ask!'}]"
71,"[{'role': 'assistant', 'type': 'message', 'content': ""To calculate the average salary, we need to use the original `salary_in_thousands_of_dollars` column without any transformations applied. Let's compute the mean salary from the unaltered dataset.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the mean of the original salary column, ignoring any NaN values\nmean_salary_original = data['salary_in_thousands_of_dollars'].mean()\n\nmean_salary_original""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(1248.5281899109793)'}, {'role': 'assistant', 'type': 'message', 'content': ""The average salary, using the original untransformed data, is approximately $1,248.528. If there's anything else you'd like to know or work on, feel free to let me know!""}]"
72,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average mpg, dropping rows with missing values in 'mpg'\navg_mpg = data['mpg'].dropna().mean()\n\n# Round to 3 decimal places\navg_mpg_rounded = round(avg_mpg, 3)\navg_mpg_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(23.446)'}, {'role': 'assistant', 'type': 'message', 'content': 'The average miles per gallon (mpg) for the entire dataset is approximately **23.446**. If you have any more questions or need further analysis, please let me know!'}]"
73,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average mpg for cars of model year 70, dropping rows with missing values in 'mpg'\nmodel_year_70_avg_mpg = data[data['model year'] == 70]['mpg'].dropna().mean()\n\n# Round to 3 decimal places\nmodel_year_70_avg_mpg_rounded = round(model_year_70_avg_mpg, 3)\nmodel_year_70_avg_mpg_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n   3804 try:\n-> 3805     return self._engine.get_loc(casted_key)\n   3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 'model year'\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[446], line 4\n      2 pass\n      3 print('##active_line2##')\n----> 4 model_year_70_avg_mpg = data[data['model year'] == 70]['mpg'].dropna().mean()\n      5 print('##active_line3##')\n      6 pass\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/frame.py:4102, in DataFrame.__getitem__(self, key)\n   4100 if self.columns.nlevels > 1:\n   4101     return self._getitem_multilevel(key)\n-> 4102 indexer = self.columns.get_loc(key)\n   4103 if is_integer(indexer):\n   4104     indexer = [indexer]\n\nFile ~/anaconda3/envs/open-interpreter/lib/python3.11/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3807     if isinstance(casted_key, slice) or (\n   3808         isinstance(casted_key, abc.Iterable)\n   3809         and any(isinstance(x, slice) for x in casted_key)\n   3810     ):\n   3811         raise InvalidIndexError(key)\n-> 3812     raise KeyError(key) from err\n   3813 except TypeError:\n   3814     # If we have a listlike key, _check_indexing_error will raise\n   3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3816     #  the TypeError.\n   3817     self._check_indexing_error(key)\n\nKeyError: 'model year'""}, {'role': 'assistant', 'type': 'message', 'content': ""It seems like there's an issue with accessing the column labeled `'model year'`. It might be named differently in the CSV file. I will check the column names to ensure we're using the correct labels. Let's inspect the first few rows and see the column headers.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': '# Display the first few rows of the dataset to check column names\ndata.head()'}, {'role': 'computer', 'type': 'code', 'format': 'html', 'content': '<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=""1"" class=""dataframe"">\n  <thead>\n    <tr style=""text-align: right;"">\n      <th></th>\n      <th>mpg</th>\n      <th>cylinders</th>\n      <th>displacement</th>\n      <th>horsepower</th>\n      <th>weight</th>\n      <th>acceleration</th>\n      <th>modelyear</th>\n      <th>origin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>18.0</td>\n      <td>8</td>\n      <td>307.0</td>\n      <td>130.0</td>\n      <td>3504.0</td>\n      <td>12.0</td>\n      <td>70</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>15.0</td>\n      <td>8</td>\n      <td>350.0</td>\n      <td>165.0</td>\n      <td>3693.0</td>\n      <td>11.5</td>\n      <td>70</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>18.0</td>\n      <td>8</td>\n      <td>318.0</td>\n      <td>150.0</td>\n      <td>3436.0</td>\n      <td>11.0</td>\n      <td>70</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>16.0</td>\n      <td>8</td>\n      <td>304.0</td>\n      <td>150.0</td>\n      <td>3433.0</td>\n      <td>12.0</td>\n      <td>70</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>17.0</td>\n      <td>8</td>\n      <td>302.0</td>\n      <td>140.0</td>\n      <td>3449.0</td>\n      <td>10.5</td>\n      <td>70</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Displayed on the user's machine.""}, {'role': 'assistant', 'type': 'message', 'content': ""The correct column name for the model year is `modelyear`, not `model year`. I'll now calculate the average miles per gallon (mpg) for cars of model year 70 using the correct column name.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average mpg for cars of model year 70 using the correct column name\nmodel_year_70_avg_mpg = data[data['modelyear'] == 70]['mpg'].dropna().mean()\n\n# Round to 3 decimal places\nmodel_year_70_avg_mpg_rounded = round(model_year_70_avg_mpg, 3)\nmodel_year_70_avg_mpg_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(17.69)'}, {'role': 'assistant', 'type': 'message', 'content': 'The average miles per gallon (mpg) for cars of model year 70 is approximately **17.690**. If you have any more questions or need further analysis, feel free to ask!'}]"
74,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Filter out cars of model year 75 or later\ncars_75_or_later = data[data['modelyear'] >= 75]\n\n# Calculate the number of such cars\nnum_cars_75_or_later = cars_75_or_later.shape[0]\n\n# Calculate the mean horsepower, dropping rows with missing values in 'horsepower'\nmean_horsepower_75_or_later = cars_75_or_later['horsepower'].dropna().mean()\n\n# Round to 3 decimal places\nmean_horsepower_75_or_later_rounded = round(mean_horsepower_75_or_later, 3)\n\nnum_cars_75_or_later, mean_horsepower_75_or_later_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(242, np.float64(93.971))'}, {'role': 'assistant', 'type': 'message', 'content': 'There are **242** cars of model year 75 or later. The mean horsepower of these cars is approximately **93.971**. If you need further assistance or have additional queries, feel free to ask!'}]"
75,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy import stats\n\n# Temporarily drop missing values in 'acceleration' and 'weight'\nacceleration = data['acceleration'].dropna()\nweight = data['weight'].dropna()\n\n# Align the series to each other by index\ndf_clean = pd.DataFrame({'acceleration': acceleration, 'weight': weight}).dropna()\n\n# Calculate the correlation and p-value\ncorr_coef, p_value = stats.pearsonr(df_clean['acceleration'], df_clean['weight'])\n\n# Round to 3 decimal places\ncorr_coef_rounded = round(corr_coef, 3)\np_value_rounded = round(p_value, 3)\n\ncorr_coef_rounded, p_value_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(-0.417), np.float64(0.0))'}, {'role': 'assistant', 'type': 'message', 'content': 'The correlation coefficient between acceleration and weight is approximately **-0.417**, indicating a moderate negative correlation. The p-value is **0.000**, which is below the significance level of 0.05, suggesting that the correlation is statistically significant.\n\nIf you have further questions or need additional analysis, feel free to ask!'}]"
76,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import r2_score\n\n# Prepare the data for linear regression (train set only)\ntrain_data_clean = train_data.dropna(subset=['acceleration', 'weight'])\nX_train = train_data_clean[['weight']]\ny_train = train_data_clean['acceleration']\n\n# Fit the linear regression model\nregressor = LinearRegression()\nregressor.fit(X_train, y_train)\n\n# Get the coefficient for weight\nweight_coefficient = regressor.coef_[0]\n\n# Calculate R-squared on the train set\ny_train_pred = regressor.predict(X_train)\ntrain_r_squared = r2_score(y_train, y_train_pred)\n\n# Round the results\nweight_coefficient_rounded = round(weight_coefficient, 3)\ntrain_r_squared_rounded = round(train_r_squared, 3)\n\nweight_coefficient_rounded, train_r_squared_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(-0.001), 0.154)'}, {'role': 'assistant', 'type': 'message', 'content': 'The linear regression model predicts acceleration from weight with the following results:\n\n- **Coefficient for weight**: approximately \\(-0.001\\)\n- **R-squared value on the training set**: approximately \\(0.154\\)\n\nThis indicates a slight negative influence of weight on acceleration. If you need further assistance, feel free to ask!'}]"
77,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create the new 'heavy' variable\ntrain_data['heavy'] = train_data['weight'].apply(lambda x: 'heavy' if x >= 3200 else 'light')\ntest_data['heavy'] = test_data['weight'].apply(lambda x: 'heavy' if x >= 3200 else 'light')\n\n# Count the number of 'heavy' observations in the entire dataset\nheavy_count = data['weight'].apply(lambda x: 'heavy' if x >= 3200 else 'light').value_counts()['heavy']\n\nheavy_count""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.int64(147)'}, {'role': 'assistant', 'type': 'message', 'content': 'There are **147** observations categorized as ""heavy"" in the dataset. If you have more questions or need further analysis, feel free to let me know!'}]"
78,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Add 'heavy' classification to the entire dataset for analysis\ndata['heavy'] = data['weight'].apply(lambda x: 'heavy' if x >= 3200 else 'light')\n\n# Temporary drop rows with missing values in 'mpg' for t-test\nmpg_data = data.dropna(subset=['mpg', 'heavy'])\n\n# Separate mpg data based on 'heavy' classification\nheavy_mpg = mpg_data[mpg_data['heavy'] == 'heavy']['mpg']\nlight_mpg = mpg_data[mpg_data['heavy'] == 'light']['mpg']\n\n# Perform an independent t-test\nstat, p_value = stats.ttest_ind(heavy_mpg, light_mpg, equal_var=False)\n\n# Round the p-value for reporting\np_value_rounded = round(p_value, 3)\n\np_value_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.0)'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value for the difference in average miles per gallon (mpg) between heavy and light vehicles is **0.000**, which is below the significance level of 0.05. This indicates that there is a statistically significant difference in average mpg between heavy and light vehicles.\n\nIf you have any more inquiries or need further assistance, feel free to ask!'}]"
79,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create the new 'powerful' variable\ntrain_data['powerful'] = train_data['cylinders'].apply(lambda x: 'powerful' if x == 8 else 'weak')\ntest_data['powerful'] = test_data['cylinders'].apply(lambda x: 'powerful' if x == 8 else 'weak')\ndata['powerful'] = data['cylinders'].apply(lambda x: 'powerful' if x == 8 else 'weak')\n\n# Count the number of 'weak' vehicles in the entire dataset\nweak_count = data['powerful'].value_counts()['weak']\n\nweak_count""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.int64(289)'}, {'role': 'assistant', 'type': 'message', 'content': 'There are **289** vehicles categorized as ""weak"" in the dataset. If you have more questions or need further analysis, feel free to ask!'}]"
80,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create a contingency table for 'powerful' and 'heavy'\ncontingency_table = pd.crosstab(data['powerful'], data['heavy'])\n\n# Perform the Chi-squared test for independence\nchi2_stat, p_value, dof, expected = stats.chi2_contingency(contingency_table)\n\n# Round the p-value for reporting\np_value_rounded = round(p_value, 3)\n\np_value_rounded""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.0)'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value for the independence test between ""powerful"" and ""heavy"" is **0.000**, which is below the significance level of 0.05. This indicates that the variables ""powerful"" and ""heavy"" are not statistically independent.\n\nIf you need more information or further analysis, feel free to let me know!'}]"
81,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': 'import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Temporarily drop missing values in \'modelyear\'\nmodel_year_data = data[\'modelyear\'].dropna()\n\n# Visual inspection using a histogram and Q-Q plot\nplt.figure(figsize=(10, 4))\nplt.subplot(1, 2, 1)\nsns.histplot(model_year_data, kde=True)\nplt.title(\'Histogram of Model Year\')\nplt.subplot(1, 2, 2)\nstats.probplot(model_year_data, dist=""norm"", plot=plt)\nplt.title(\'Q-Q Plot of Model Year\')\nplt.tight_layout()\nplt.show()'}, {'role': 'computer', 'type': 'image', 'format': 'base64.png', 'content': 'iVBORw0KGgoAAAANSUhEUgAAA94AAAGGCAYAAACNL1mYAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAk0FJREFUeJzt3QdcVeUbB/Afe6ggoAwVN+69Z5qaWGaaNizMkamludOyXKXmypma2t+Zo7TUstLco9zmzE1uBVyIogzh/j/Pe7p4QUDAC3f9vn1Ol3Pu5dyXA973PO94XjudTqcDEREREREREWUL++w5LREREREREREJBt5ERERERERE2YiBNxEREREREVE2YuBNRERERERElI0YeBMRERERERFlIwbeRERERERERNmIgTcRERERERFRNmLgTURERERERJSNGHgTERERERERZSMG3mT1ihYtis6dO5u6GFZv4sSJKF68OBwcHFClShWYm23btsHOzk49ZtbChQvV9164cCFbykZERJZJ6oaRI0fCnOzfvx/16tVDrly5VPkOHz4Ma7o3M8drTpQRDLzJougDoAMHDqT6fOPGjVGhQoVnfp/ff/+dH+qZsGHDBgwePBj169fHggUL8OWXX6b5Wqlo5Xfo4eGBhw8fPvH82bNn1fOyffXVV7AE8fHxqFixIkqUKJHqzyQBu7u7O15//XWTlI+IyJz9888/6NChAwoWLAgXFxcUKFBA7Z84ccIk55PPbH09JJs0KBcuXBivvvqq0YJYKYvcZxi7QVfqI6lrbt++jSlTpuC7775DkSJF0m2Qlm3JkiWpvkbqdXneGPdWOWXcuHGqzH/88Ueqz7/00kvw9PTEtWvXcrxsZNsYeJPVO336NL799ttMB96ff/55tpXJ2mzZsgX29vaYN28eOnbsqCq19Dg6OuLBgwdYu3btE88tXboUrq6usCROTk6YO3cuzp8/j1GjRj3x/IcffghnZ2dMnz7dJOUjIjJXq1atQrVq1bB582Z06dIFs2bNQteuXVW9Isd//vlnk53vrbfeUoHr/Pnz8fbbb6tz1KlTxyjBtwTecp9h7MA7NDQUFy9exEcffYTu3burBgcvL690v0fq3GXLlj1xXMq2a9cui6uTBw4cqBrDe/bs+URj+MqVK7Fu3TqMHTtWNcgQ5SQG3mT1pLVbAiNLEh0dDUsSEREB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RGTN9bXVB95SiQcGBpq6GERERJl2+fJltfyRLWB9TURE1lxfW33gLS3n+ovh4eFh6uIQERE9VVRUlApC9XWYLWB9TURE1lxfW33grR+uJpU4K3IiIrIktjTkmvU1ERFZc31tGxPHiIiIiIiIiEyEgTcRERERERFRNmLgTURERERERJSNGHgTERERERERZSMG3kRERERERETZiIE3ERERERERUTZi4E1ERERERESUjRh4ExEREREREWUjBt5ERERERERE2YiBNxEREREREdmGiAiTvC0DbyIiIiIiIrJuiYnAV18BRYoAO3bk+Ns75vg7EpHVuHTpEm7evAlzlC9fPhQuXNjUxSAiIiIiU7t8GejUCdi6VdtfsQJ47rkcLQIDbyLKctBdpmxZPHzwAObIzd0dp06eZPBNREREZMtWrAB69AAiIwF3d2DaNKBr1xwvBgNvIsoS6emWoDvk44nwK1wC5iT8UiiWjh+kysjAm4iIiMgGRUUBvXsDixdr+zVrAkuXAkFBJikOA28ieiYSdBcKKm/qYhARERERaXbtAjp0AM6fB+ztgU8/BYYPB5ycYCoMvImIiIiIiMjyxccDo0YBY8ZoydSKFgW++w5o0MDUJWPgTURERERERBbu3Dmtl3vvXm3/nXeAr78GPD1hDky+nNjVq1fRoUMH+Pj4wM3NDRUrVsSBAweSntfpdBg+fDgCAgLU882aNcPZs2dNWmYiIiIiIiIyAzodMG8eUKWKFnTnzQt8/702t9tMgm6TB9537txB/fr14eTkhHXr1uHEiROYNGkSvLy8kl4zYcIETJ8+HbNnz8bevXuRK1cuBAcHIyYmxpRFJyIiIiIiIlO6dQto1w547z0gOhpo3Bg4ehR4802YG5MONR8/fjwCAwOxYMGCpGPFihVL1ts9depUDB06FK1bt1bHFi9eDD8/P6xZswbt27c3SbmJiIiIiIjIhDZu1Nbmvn5dS5o2ejQwcCDg4ABzZNIe719++QU1atTA66+/Dl9fX1StWhXffvtt0vPnz59HWFiYGl6u5+npidq1a2P37t2pnjM2NhZRUVHJNiIiIiIiIrICMTFA//5A8+Za0F2mDLBnDzB4sNkG3SYPvP/991988803CAoKwh9//IEPPvgAffr0waJFi9TzEnQL6eE2JPv651IaO3asCs71m/SoExERERERkYU7dgyo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qFixIg4cOJD0fOfOnWFnZ5dsa9GihWkK6+YGbNgA7NzJoJuIiMwCe7yJiIgoXXfu3EH9+vXx/PPPY926dcifPz/Onj0LLy+vZK+TQHvBggVJ+y6mTGBWqJDp3puIiCgFBt5ERESUrvHjxyMwMDBZUF2sWLEnXieBtr+/fw6XjoiIyPxxqDkRERGl65dffkGNGjXw+uuvw9fXF1WrVsW33377xOu2bdumni9dujQ++OAD3Lp1yyTlJSIiMjcMvImIiChd//77L7755hsEBQXhjz/+UEF1nz59sGjRomTDzBcvXozNmzerHvLt27fjxRdfRIKspZ2K2NhYREVFJduIiIisFYeaExERUboSExNVj/eXX36p9qXH+/jx45g9ezY6deqkjrVv3z7p9ZJ4rVKlSihRooTqBW/atOkT5xw7diw+//zzHPwpiIiITIc93kRERJSugIAAlCtXLtmxsmXL4tKlS2l+T/HixZEvXz6cO3cu1eeHDBmCu3fvJm2XL182ermJiIjMBXu8iYiIKF2S0fz06dPJjp05cwZFihRJ83uuXLmi5nhL0J4aScRm0qznREREOcgierxnzpyJokWLwtXVFbVr18a+fftMXSQiIiKb0b9/f+zZs0cNNZce7GXLlmHu3Lno1auXev7+/fsYNGiQes2FCxfUPO/WrVujZMmSCA4ONnXxiYiITM7sA+8ffvgBAwYMwIgRI/D333+jcuXKqhKPiIgwddGIiIhsQs2aNbF69WosX74cFSpUwKhRozB16lSEhISo5x0cHHD06FG88sorKFWqFLp27Yrq1atj586d7NUmIiKyhKHmkydPRrdu3dClSxe1L4lcfvvtN8yfPx+ffPKJqYtHRERkE15++WW1pcbNzU1lOyciIiIL7PGOi4vDwYMH0axZs6Rj9vb2an/37t0mLRsRERERERGRxfd437x5U63/6efnl+y47J86dSrNdUFl05NMqcIY64PKHDZx5ew/iH34AOYm/FKoegy7cAahudxhTli2rGHZsoZls87ymXPZblw5n1RPGKO+0Z9Dp9PBVuh/Vq7nTUREliIz9bWdzoxr9WvXrqFgwYLYtWsX6tatm3R88ODB2L59O/bu3fvE94wcOZLrghIRkVWQJbYKFSoEWyBZ0AMDA01dDCIiomypr826x1vW/5SELeHh4cmOy76/v3+a64JKMja9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vPEGwsPDn+i5/t///odixYqp8wgZCv3ee+8hf/786vuaNGmCI0eOJE3ZkveRfX0vvRxLbaj5lStX8NZbb8Hb21vVyfKz7N27Vz0n9aSUTepVKV/NmjWxadOmTF3LhIQEDBgwIKn+HTx4MDp16pSs5zm14eryMxuOLJg8eTIqVqyoyii91D179sT9+/efmKb2xx9/oGzZsqq8LVq0SGpEkXMtWrRI/T7010TuPVIONU/Nn3/+iYYNG8LNzU29d58+fdT9jt6sWbMQFBSkfjdyrV577bVMXSOirGDgTWRhpBLKly8f9u3bp4LwDz74AK+//rq6efj777/RvHlzFcQ+ePAAV69exUsvvaQqXqnMv/nmG8ybNw+jR49OOt+gQYNUcC4V24YNG1SlJucx9OGHH2L37t34/vvvcfToUfV+UjmePXv2ifJJZdysWTMsWLAg2XHZlyFjEpTLzYfccFStWlUF6BJky02L3LzoSQUpFb88v3nzZvV9r776alLgricNCX379sXJkycRHBxsxCtNRETW6LPPPlONzFK/ODo64t133016bufOnaoxWuqVEydOYM6cOSpAHDNmjHpe6iAJbG/fvq3qzo0bN+Lff//Fm2++mew9zp07h59++gmrVq1KChCl7oyIiFCN4xL8S3DftGlTdS75/oEDB6J8+fIq8JQt5TmFBK7S2Cz1+y+//KLqdgmM9XWjPC/1vtSbhw4dUnV1q1atVGNBRsm1kZ95/vz5KoCV8q1evTrT11nq7enTp+Off/5R9y5btmxRZTUk9ypfffUVvvvuO+zYsUOVUxr6hTzKfYE+GJdN7nWeRhof5HvatWun7lmkgV5+DrmXEfJ7l0D8iy++UI0ucg/y3HPPZfrnI8o0HRFZjEaNGukaNGiQtP/o0SNdrly5dO+8807SsevXr+vkn/bu3bt1n376qa506dK6xMTEpOdnzpypy507ty4hIUF37949nbOzs27FihVJz9+6dUvn5uam69u3r9q/ePGizsHBQXf16tVkZWnatKluyJAh6usFCxboPD09k5774YcfdF5eXrqYmBi1f/DgQZ2dnZ3u/Pnzan/UqFG65s2bJzvf5cuXVblPnz6d6s9+48YN9fyxY8fUvpxL9qdOnZqla0lERNYpZZ2kt3XrVlVvbNq0KenYb7/9po49fPgwqW778ssvk33fd999pwsI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'}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""Displayed on the user's machine.""}, {'role': 'assistant', 'type': 'message', 'content': 'The histogram shows that the model year data is not evenly distributed across years. The Q-Q plot indicates deviations from the red line, particularly at the tails, suggesting that the data is not normally distributed.\n\nIf you need further assistance, feel free to ask!'}]"
82,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Count unique blood types in the entire dataset\ndifferent_blood_types = dataset['Blood Type'].nunique()\ndifferent_blood_types""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '8'}, {'role': 'assistant', 'type': 'message', 'content': 'There are 8 different blood types in the dataset. If you have any more questions or need further analysis, feel free to ask!'}]"
83,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Count unique insurance providers in the entire dataset\ndifferent_insurance_providers = dataset['Insurance Provider'].nunique()\ndifferent_insurance_providers""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '5'}, {'role': 'assistant', 'type': 'message', 'content': ""There are 5 different insurance providers in the dataset. Let me know if there's anything else you'd like to explore!""}]"
84,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average billing amount for each insurance provider\naverage_billing_by_provider = dataset.groupby('Insurance Provider')['Billing Amount'].mean()\n\n# Identify the insurance provider with the highest average billing amount\nhighest_billing_provider = average_billing_by_provider.idxmax()\nhighest_avg_billing = average_billing_by_provider.max()\n\nhighest_billing_provider, highest_avg_billing""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""('Medicare', np.float64(25615.990507988467))""}, {'role': 'assistant', 'type': 'message', 'content': 'The insurance provider associated with the highest average billing amount is **Medicare**, with an average billing amount of **25,615.991**. If you need further analysis, feel free to ask!'}]"
85,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import ttest_ind\n\n# Remove rows with missing values in 'Gender' or 'Billing Amount'\ndataset_clean = dataset.dropna(subset=['Gender', 'Billing Amount'])\n\n# Separate billing amounts based on gender\nbilling_male = dataset_clean[dataset_clean['Gender'] == 'Male']['Billing Amount']\nbilling_female = dataset_clean[dataset_clean['Gender'] == 'Female']['Billing Amount']\n\n# Perform t-test to compare means\nstatistic, p_value = ttest_ind(billing_male, billing_female)\np_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.2554373668991071)'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value for the comparison of average billing amounts between males and females is **0.255**. Since this value is greater than the significance level of 0.05, there is no statistically significant difference in average billing amounts between males and females in the dataset.'}]"
86,"[{'role': 'assistant', 'type': 'message', 'content': ""To perform linear regression to predict the billing amount from gender and insurance provider, I will follow these steps:\n\n1. **Encode Categorical Variables:** Convert gender and insurance provider into numerical formats using one-hot encoding.\n2. **Fit a Linear Regression Model:** Train the model on the training set.\n3. **Evaluate the Model:** Calculate the R-squared value on the training set and the RMSE on the test set.\n\nLet's start by encoding the categorical variables and fitting the model.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.preprocessing import OneHotEncoder\nimport numpy as np\n\n# Drop missing values in relevant columns\ntrain_set_clean = train_set.dropna(subset=['Gender', 'Insurance Provider', 'Billing Amount'])\ntest_set_clean = test_set.dropna(subset=['Gender', 'Insurance Provider', 'Billing Amount'])\n\n# One-hot encode categorical variables\nencoder = OneHotEncoder(drop='first', sparse=False)\nencoded_train = encoder.fit_transform(train_set_clean[['Gender', 'Insurance Provider']])\nencoded_test = encoder.transform(test_set_clean[['Gender', 'Insurance Provider']])\n\n# Prepare feature matrices\nX_train = np.hstack((encoded_train, ))\nX_test = np.hstack((encoded_test, ))\n\ny_train = train_set_clean['Billing Amount']\ny_test = test_set_clean['Billing Amount']\n\n# Fit the linear regression model\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Calculate train R-squared\ntrain_r_squared = model.score(X_train, y_train)\n\n# Predict and calculate test RMSE\ny_pred_test = model.predict(X_test)\ntest_rmse = np.sqrt(mean_squared_error(y_test, y_pred_test))\n\ntrain_r_squared, test_rmse""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[462], line 22\n     20 pass\n     21 print('##active_line11##')\n---> 22 encoder = OneHotEncoder(drop='first', sparse=False)\n     23 print('##active_line12##')\n     24 encoded_train = encoder.fit_transform(train_set_clean[['Gender', 'Insurance Provider']])\n\nTypeError: OneHotEncoder.__init__() got an unexpected keyword argument 'sparse'""}, {'role': 'assistant', 'type': 'message', 'content': ""It seems like there was a typo in my code. The correct parameter for disabling sparse matrices in `OneHotEncoder` is `sparse_output`, not `sparse`. Let's fix this and rerun the code.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Update and re-run with the correct parameter for OneHotEncoder\nencoder = OneHotEncoder(drop='first', sparse_output=False)  # Correcting the parameter\nencoded_train = encoder.fit_transform(train_set_clean[['Gender', 'Insurance Provider']])\nencoded_test = encoder.transform(test_set_clean[['Gender', 'Insurance Provider']])\n\n# Prepare feature matrices\nX_train = encoded_train  # encoding for Gender and Insurance Provider\nX_test = encoded_test\n\ny_train = train_set_clean['Billing Amount']\ny_test = test_set_clean['Billing Amount']\n\n# Fit the linear regression model\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\n# Calculate train R-squared\ntrain_r_squared = model.score(X_train, y_train)\n\n# Predict and calculate test RMSE\ny_pred_test = model.predict(X_test)\ntest_rmse = np.sqrt(mean_squared_error(y_test, y_pred_test))\n\ntrain_r_squared, test_rmse""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(5.325053043436778e-05, np.float64(14104.311196486797))'}, {'role': 'assistant', 'type': 'message', 'content': 'The train R-squared of the linear regression model is approximately **0.000** (indicating that gender and insurance provider explain very little variance in billing amounts), and the test RMSE is **14,104.311**. This indicates a substantial error in predictions, suggesting the model may be a poor fit with these features alone. Let me know if you need further analysis or adjustments!'}]"
87,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import chi2_contingency\n\n# Drop missing values in relevant columns\ndataset_clean_independence = dataset.dropna(subset=['Blood Type', 'Gender'])\n\n# Create a contingency table for 'Blood Type' and 'Gender'\ncontingency_table = pd.crosstab(dataset_clean_independence['Blood Type'], dataset_clean_independence['Gender'])\n\n# Perform the Chi-squared test for independence\nchi2_stat, p_value, dof, expected = chi2_contingency(contingency_table)\np_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.04742186342131232)'}, {'role': 'assistant', 'type': 'message', 'content': 'The p-value for the Chi-squared test for independence between blood type and gender is **0.047**. Since this value is less than the significance level of 0.05, we reject the null hypothesis and conclude that blood type and gender are statistically dependent in the dataset.'}]"
88,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Drop missing values in relevant columns\ntrain_set_clean_age = train_set.dropna(subset=['Age', 'Billing Amount'])\ntest_set_clean_age = test_set.dropna(subset=['Age', 'Billing Amount'])\n\n# Prepare feature matrices\nX_train_age = train_set_clean_age[['Age']]\ny_train_age = train_set_clean_age['Billing Amount']\n\n# Fit the linear regression model\nmodel_age = LinearRegression()\nmodel_age.fit(X_train_age, y_train_age)\n\n# Get the coefficient and intercept\ncoef_age = model_age.coef_[0]\nintercept_age = model_age.intercept_\n\ncoef_age, intercept_age""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(-6.960488948383486), np.float64(25870.208482635946))'}, {'role': 'assistant', 'type': 'message', 'content': 'In the linear regression model with billing amount regressed on age, the coefficient associated with age is approximately **-6.960**, and the intercept value is **25,870.208**. This suggests that for each additional year of age, the billing amount decreases on average by about 6.960, holding other factors constant.'}]"
89,"[{'role': 'assistant', 'type': 'message', 'content': ""To min-max scale the billing amount, we'll scale it using the training set's minimum and maximum values and then apply the same transformation to the test set. Once scaled, we'll calculate the variance of the scaled billing amounts.\n\nLet's start by performing the min-max scaling.""}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from sklearn.preprocessing import MinMaxScaler\n\n# Min-max scale the billing amount\nscaler = MinMaxScaler()\n\n# Fit the scaler on the training set and transform both train and test sets\ntrain_set_clean['Billing Amount Scaled'] = scaler.fit_transform(train_set_clean[['Billing Amount']])\ntest_set_clean['Billing Amount Scaled'] = scaler.transform(test_set_clean[['Billing Amount']])\n\n# Calculate the variance of the scaled billing amount in the entire dataset\ntotal_set_scaled = pd.concat([train_set_clean, test_set_clean])\nvariance_scaled_billing = total_set_scaled['Billing Amount Scaled'].var()\n\nvariance_scaled_billing""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.06732055097560175)'}, {'role': 'assistant', 'type': 'message', 'content': 'After min-max scaling the billing amount, the variance of the scaled billing amounts is approximately **0.067**. If you need more analysis or any other transformations, just let me know!'}]"
90,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average billing amount across the entire dataset\naverage_billing_amount = dataset['Billing Amount'].mean()\naverage_billing_amount""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(25539.316097211795)'}, {'role': 'assistant', 'type': 'message', 'content': 'The average billing amount in the dataset is approximately **25,539.316**. If you have any more questions or need further analysis, feel free to ask!'}]"
91,"[{'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the average billing amount for each medical condition\naverage_billing_by_condition = dataset.groupby('Medical Condition')['Billing Amount'].mean()\n\n# Identify the medical condition with the highest average billing amount\nhighest_billing_condition = average_billing_by_condition.idxmax()\nhighest_avg_billing_cond = average_billing_by_condition.max()\n\nhighest_billing_condition, highest_avg_billing_cond""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': ""('Obesity', np.float64(25805.971259050853))""}, {'role': 'assistant', 'type': 'message', 'content': 'The medical condition associated with the highest average billing amount is **Obesity**, with an average billing amount of **25,805.971**. If you need more detailed analysis, let me know!'}]"
92,"[{'role': 'assistant', 'type': 'message', 'content': 'To compute the mean and median of ""SepalLengthCm"", we will use the entire dataset as per the rules outlined. Let\'s perform this analysis.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Compute the mean and median of 'SepalLengthCm' in the entire dataset\nsepal_length_mean = dataset['SepalLengthCm'].mean()\nsepal_length_median = dataset['SepalLengthCm'].median()\n\nsepal_length_mean, sepal_length_median""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(5.843333333333334), np.float64(5.8))'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean of ""SepalLengthCm"" is approximately 5.843, and the median is 5.800. If you have further instructions or questions, feel free to ask!'}]"
93,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine the tenth largest ""SepalLengthCm"" value, we need to sort the ""SepalLengthCm"" column in descending order and then select the tenth value. I will perform this step now.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Sort the 'SepalLengthCm' column in descending order and get the 10th largest value\ntenth_largest_sepal_length = dataset['SepalLengthCm'].sort_values(ascending=False).iloc[9]\ntenth_largest_sepal_length""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(7.2)'}, {'role': 'assistant', 'type': 'message', 'content': 'The tenth largest ""SepalLengthCm"" value is 7.200. Let me know if there\'s anything else you\'d like to analyze!'}]"
94,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the number of different species categories, we will examine the unique values in the ""Species"" column. Let\'s do this now.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Get the number of unique species in the dataset\nunique_species_count = dataset['Species'].nunique()\nunique_species_count""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '3'}, {'role': 'assistant', 'type': 'message', 'content': 'There are 3 different species categories in the dataset. If you need further analysis or have additional questions, please let me know!'}]"
95,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the mean ""SepalLengthCm"" for the species ""Iris-setosa"", we will filter the dataset for this species and then compute the mean. Let\'s perform this operation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Filter the dataset for 'Iris-setosa' and calculate the mean of 'SepalLengthCm'\nsetosa_mean_sepal_length = dataset[dataset['Species'] == 'Iris-setosa']['SepalLengthCm'].mean()\nsetosa_mean_sepal_length""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(5.006)'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean ""SepalLengthCm"" for the species ""Iris-setosa"" is approximately 5.006. If you have more questions or need further analysis, feel free to ask!'}]"
96,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the correlation between ""PetalWidthCm"" and ""PetalLengthCm"" and determine the correlation coefficient and p-value, we will use statistical methods. Let\'s compute these values.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""from scipy.stats import pearsonr\n\n# Calculate the Pearson correlation coefficient and p-value\ncorrelation_coefficient, p_value = pearsonr(dataset['PetalWidthCm'], dataset['PetalLengthCm'])\ncorrelation_coefficient, p_value""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(0.9627570970509662), np.float64(5.7766609884951665e-86))'}, {'role': 'assistant', 'type': 'message', 'content': 'The correlation coefficient between ""PetalWidthCm"" and ""PetalLengthCm"" is approximately 0.963, indicating a strong positive correlation. The p-value is effectively 0 (5.777e-86), which suggests the correlation is statistically significant. If you have any more queries or need further assistance, let me know!'}]"
97,"[{'role': 'assistant', 'type': 'message', 'content': 'To create the new variable ""PetalAreaCm"" as the product of ""PetalWidthCm"" and ""PetalLengthCm"", and then calculate its mean and standard deviation, we\'ll first add this new variable to the dataset and perform the calculations. Let\'s proceed with these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Create the new variable 'PetalAreaCm'\ndataset['PetalAreaCm'] = dataset['PetalWidthCm'] * dataset['PetalLengthCm']\n\n# Calculate the mean and standard deviation of 'PetalAreaCm'\npetal_area_mean = dataset['PetalAreaCm'].mean()\npetal_area_std = dataset['PetalAreaCm'].std()\npetal_area_mean, petal_area_std""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '(np.float64(5.7931333333333335), np.float64(4.713498983416319))'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean of the newly created variable ""PetalAreaCm"" is approximately 5.793, and the standard deviation is approximately 4.713. Feel free to ask if you have more questions or need further analysis!'}]"
98,"[{'role': 'assistant', 'type': 'message', 'content': 'To find the mean ""PetalAreaCm"" specifically for the species ""Iris-setosa,"" we\'ll filter the dataset for this species and calculate the mean of the ""PetalAreaCm"" variable. Let\'s proceed with that calculation.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Filter the dataset for 'Iris-setosa' and calculate the mean of 'PetalAreaCm'\nsetosa_mean_petal_area = dataset[dataset['Species'] == 'Iris-setosa']['PetalAreaCm'].mean()\nsetosa_mean_petal_area""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': 'np.float64(0.36280000000000007)'}, {'role': 'assistant', 'type': 'message', 'content': 'The mean ""PetalAreaCm"" for the species ""Iris-setosa"" is approximately 0.363. If there\'s anything else you need, feel free to ask!'}]"
99,"[{'role': 'assistant', 'type': 'message', 'content': 'To determine if there is a statistically significant correlation between ""SepalLengthCm"" and ""PetalAreaCm"", we will calculate the Pearson correlation coefficient and its associated p-value. Let\'s do that now.'}]"
100,"[{'role': 'assistant', 'type': 'message', 'content': 'To create the ""LargeArea"" variable, we\'ll first determine the median of ""PetalAreaCm"". Then, we\'ll label the observations as ""large"" if their ""PetalAreaCm"" is at least the median and ""small"" if it\'s less. Finally, we\'ll count the number of ""large"" observations. Let\'s proceed with these steps.'}, {'role': 'assistant', 'type': 'code', 'format': 'python', 'content': ""# Calculate the median of 'PetalAreaCm'\npetal_area_median = dataset['PetalAreaCm'].median()\n\n# Engineer the 'LargeArea' variable\nimport numpy as np\ndataset['LargeArea'] = np.where(dataset['PetalAreaCm'] >= petal_area_median, 'large', 'small')\n\n# Count the number of 'large' observations\nlarge_count = dataset[dataset['LargeArea'] == 'large'].shape[0]\nlarge_count""}, {'role': 'computer', 'type': 'console', 'format': 'output', 'content': '75'}, {'role': 'assistant', 'type': 'message', 'content': 'There are 75 observations labeled as ""large"" in the ""LargeArea"" variable. If you have more analyses to conduct or questions to ask, feel free to let me know!'}]"
